: '@(#)vnmr2sc.sh 22.1 03/24/08 1991-2001 '
#
#
# Copyright (C) 2015  University of Oregon
# 
# You may distribute under the terms of either the GNU General Public
# License or the Apache License, as specified in the LICENSE file.
# 
# For more information, see the LICENSE file.
# 
#
#!/bin/sh
#
# vnmr2sc - VNMR (C) to SpinCAD Pulse Sequence Translator
# =======================================================
#
# Description:  vnmr2sc <-d<ebug>> seqname expdir <rfchans <gradchans>>
#
#	  	vnmr2sc requires the two files "dpsdata" (as generated by
#		"dps(-d')" or "dps('-j')") and "dpstable" (as generated by
#		"dps(-j')") to be present in the specified experiment
#		directory. If the latter is not found, "vnmr2sc" will not
#		translate phase cycling.
#
# Arguments:	-d or -debug (optional first argument): turns on debugging
#			output. The conversion also works in debugging	mode.
#			Intermediate files are not deleted in this mode.
#		seqname: name or the target sequence, as placed in the user's
#			vnmrsys/psglib
#		expdir: current experiment directory, where "vnmr2sc" looks
#			for the files "dpsdata" and "dpstable"
#		The number of r.f. and gradient channels is determined by
#			"vnmr2sc", but two extra arguments allow to override
#			(i.e., increase) the  numbers determined by "vnmr2sc"
#
# 1999-10-23 - 1.0.01: simple pulses & delays
# 1999-10-24 - 1.0.02: status, zgradpulse, implicit (->explicit) acquisition
# 1999-10-24 - 1.0.03: r.f. gates, blanking
# 1999-10-25 - 1.0.04: rgradient, fixed docking & element numbering
# 1999-10-26 - 1.0.05: phase objects, fixed phases, oph/receiver phase
# 1999-10-27 - 1.0.06: eliminates timing corrections from C sequence
# 1999-10-27 - 1.0.07: PI, "gen" pulse, blankon/off, rfon/rfoff, power, pwrf
#                         fixes in "pending/sidechain" docking scheme
# 1999-10-29 - 1.0.08: move AP bus stuff into delays where possible,
#                         fix element IDs for proper sequence
# 1999-10-29 - 1.0.09: shaped pulses, bug fixes, comments, clean-up
# 1999-10-30 - 1.0.10: *prgon/*prgoff, offset functions,
#			  protection against missing library elements
# 1999-10-30 - 1.0.11: xgate, recon/off, rcvron/off
# 1999-10-30 - 1.0.12: 90 degrees and small angle phase shift functions
# 1999-10-31 - 1.0.13: explicit acquisition, simpulses, various fixes
# 1999-10-31 - 1.0.14: simshaped_pulse and related functions
# 1999-11-01 - 1.0.15: lk_hold/lk_sample, spare lines control
# 1999-11-06 - 1.0.16: remove 1 usec timing corrections
# 1999-11-09 - 1.0.17: soft & hardloop translation, real-time ifs;
#			  recognize predefined phase names (ct, bsctr, etc.)
# 1999-11-09 - 1.0.18: substituted real-time variables (e.g. in C functions);
#			  statusdelay
# 1999-11-10 - 1.0.19: spinlock functions, including genspinlock
# 1999-11-14 - 1.0.20: change d2/d3/d4 into t1/t2/t3 for nD experiments
# 1999-11-14 - 1.0.21: initdelay / incdelay / vdelay
# 1999-11-14 - 1.0.22: setstatus
# 1999-11-15 - 1.0.23: "i" (interactive / acqi) functions, power/pwrf/pwrm
# 1999-11-15 - 1.0.24: hsdelay now with homospoil control
# 1999-11-16 - 1.0.25: prepared for X, Y gradients / imaging gradients;
#			  revised argument definition, bug fixes etc.
# 1999-11-17 - 1.0.26: added disclaimer to pulse sequence comment
# 1999-11-24 - 1.0.27: scale pulse widths with obvious/common multipliers;
#			  properly implemented small angle phase shifting!
# 1999-11-28 - 1.0.28: added phase table extraction
# 1999-11-29 - 1.1:    full version after few refinements etc.
# 1999-11-30 - 1.1.1:  bug fixes / format improvements with phase tables
# 1999-11-30 - 1.1.2:  add power setting to selected pulse and decouple elems
# 2000-01-06 - 1.2:    adjusted for "merged" version of SpinCAD in VNMR 6.1C;
#			  adjusted for new "acquire all points" composite;
#			  prevents reconversion of SpinCAD sequence
# 2000-01-07 - 1.2.1:  bug fix with table decoding
# 2000-01-17 - 1.2.2:  substituted psgSetPhase primitive for psgPhase90 and
#                         psgPhase, even though this will have adverse effects;
#                         fixed delay due to command path search
# 2000-07-16 - 1.2.3:  adjusted attribute number and order in "decouple"
# 2001-02-06 - 1.2.4:  added "XML bracketing lines"; fixed problem with
#			  pending "front-to-front" items at the start or at
#			  the end of an "if" or of a loop; stop accumulation
#			  of debugging logs; adjustments for current set of
#			  composites
#

version_ID=1.2.4
version_date=2001-02-06
cmdname=`basename $0`

# +-----------------+
# | debugging stuff |
# +-----------------+
# Argument "-d" or "-debug" (must be first argument)
#   turns on debugging mode
debug=0
if [ $# -gt 1 ]; then
  if [ $1 = "-debug" -o $1 = "-d" ]; then
    debug=1
    shift
  fi
fi

# +-------------------+
# | check environment |
# +-------------------+
if [ x"$vnmruser" = x ]; then
  echo "$cmdname: environment variable 'vnmruser' not defined, aborting."
  exit 0
fi
if [ x"$vnmrsystem" = x ]; then
  echo "$cmdname: environment variable 'vnmrsystem' not defined, aborting."
  exit 0
fi

# +-----------------+
# | check arguments |
# +-----------------+
if [ $# -lt 2 ]; then
  echo "Usage: $cmdname <-d<ebug>> seqname expdir <rfchans <gradchans>>"
  exit 0
fi
seqname=$1
target="$vnmruser"/spincad/psglib/$1
source=$2/dpsdata
tblsource=$2/dpstable
tbltarget=$2/v2sctable
libname=sclib
expdir=`dirname $source`
curpar="$expdir"/curpar
if [ -f "$curpar" ]; then
  Cseq=`cat "$curpar" | awk '/^seqfil/ {getline; print $NF}' | sed 's/"//g'`
else
  Cseq=$seqname
fi
logfile="$vnmruser"/spincad/vnmr2sc.log
if [ -f "$logfile" ]; then
  mv "$logfile" "$logfile".prev
fi

# +-------------+
# | check files |
# +-------------+
if [ ! -f "$source" ]; then
  echo "$cmdname: file $source not found, aborting."
  exit 0
fi
if [ -f "$target" ]; then
  # target file exists / no backup found: back up current version
  if [ ! -f "$target".bk ]; then
    mv "$target" "$target".bk
  else
    rm -f "$target"
  fi
fi
# need conversion element library
library="$vnmruser"/spincad/$libname
if [ ! -d "$library" ]; then
  library="$vnmrsystem"/spincad/$libname
  if [ ! -d "$library" ]; then
    library=./"$libname"
    if [ ! -d "$library" ]; then
      echo "$cmdname: library \"$libname\" not found, aborting."
      exit 0
    fi
  fi
fi

# +-------------------------------------------------+
# | prevent re-conversion of SpinCAD pulse sequence |
# | and check for presence of compiled C sequence   |
# +-------------------------------------------------+
if [ ! -f "$vnmruser"/seqlib/$1 -a ! -f "$vnmrsystem"/seqlib/$1 ]; then
  echo "$cmdname: compiled C pulse sequence \"$1\" not found\c"
  if [ -f "$vnmruser"/seqlib/$1.psg -o -f "$vnmrsystem"/seqlib/$1.psg ]; then
    echo ""
    echo "$cmdname: sequence \"$1\" is already in SpinCAD format, aborting"
  else
    echo ", aborting"
  fi
  exit 0
fi 

# +-------------------------------------+
# | check for local SpinCAD directories |
# +-------------------------------------+
if [ ! -d "$vnmruser"/spincad ]; then
  mkdir "$vnmruser"/spincad
fi
if [ ! -d "$vnmruser"/spincad/psglib ]; then
  mkdir "$vnmruser"/spincad/psglib
fi

# +--------------------------------------------------------+
# | initial conditions / args are OK - we can get started! |
# +--------------------------------------------------------+
echo "Converting VNMR \"$Cseq.c\" pulse sequence"
echo "        to \"$seqname\" in SpinCAD format ... "
if [ ! -f "$curpar" ]; then
  echo "   $curpar not found - assuming C file is \"$Cseq.c\" ..."
fi
if [ $debug -eq 1 ]; then
  echo "SpinCAD element library used:  $library"
fi


# +-----------------------------------------------------+
# | extract phase tables from file "dpstable", if found |
# +-----------------------------------------------------+
dotables=1	# flag for availability of table data

# first check whether command 'readsctables' is found
if [ `find "$HOME"/bin/* "$vnmrsystem"/bin/* * -prune -name readsctables 2>/dev/null | wc -l` -eq 0 ]; then
  dotables=0
  echo "   executable 'readsctables' not found; no phase table conversion."
fi

# check for presence of file "dpsdata"
if [ ! -f "$tblsource" -a "$dotables" -eq 1 ]; then
  dotables=0
  echo "   table data not found; no phase table conversion."
fi

# now convert table information into appropriate format
if [ "$dotables" -eq 1 ]; then
  # remove any previous table input file
  rm -f "$tbltarget"

  # first find out now many phase values per table were generated
  tblsize=`cat "$tblsource" | grep -c '^ct='`

  if [ $debug -gt 0 ]; then
    echo "Phase / table values were stored for nt=$tblsize"
  fi

  # now find out how many tables there are in the input file
  numtables=`cat "$tblsource" | nawk 'BEGIN {
  	  tables=0
  	  getline
  	  while ((getline > 0) && ($1 != "ct="))
   	  {
            tables += NF-1
  	  }
  	  print tables
	}'`

  if [ $debug -gt 0 ]; then
    echo "$numtables tables will be extracted from $tblsource"
  fi

  # now extract tables from file "dpstable" and generate
  # suitable input file for conversion software
  cat "$tblsource" | readsctables $tblsize $numtables > "$tbltarget"

  if [ ! -s "$tbltarget" ]; then
    echo "table extraction failed - converting without tables"
    dotables=0
  else
    if [ $debug -gt 0 ]; then
      echo ""
      echo "Result of table conversion:"
      echo "==========================="
      cat "$tbltarget"
      echo ""
    fi
  fi
fi


# +--------------------------------------------------+
# | 1st NAWK pass: determine number of r.f. channels |
# +--------------------------------------------------+
channels=`cat "$source" | nawk '
  BEGIN {ch = 0}
  {
    if (($1 == 900) && (($3 > 0.0) || ($4 > 0.0)))
      ch++
  }
  END {print ch}'`
if [ $channels -eq 0 ]; then
  echo "$cmdname: file $source has improper contents - aborting."
  exit 0
fi
if [ `cat "$source" | nawk '{print $2}' | grep -c grad` -eq 0 ]; then
  gradchan=0
else
  if [ `cat "$source" | nawk '{print $2}' | egrep -c 'peloop|msloop'` -gt 0 ]
  then
    gradchan=-3
  elif [ `cat "$source" | nawk '{print $2}' | egrep -c 'obl_|oblique_'` -gt 0 ]
  then
    gradchan=3
  else
    gradchan=1
  fi
fi
if [ $# -gt 2 ]; then
  if [ $3 -gt $channels ]; then
    channels=$3
  fi
  if [ $channels -gt 8 ]; then
    channels=8
  fi
fi
if [ $# -gt 3 ]; then
  if [ $4 -gt $gradchan ]; then
    gradchan=$4
  fi
  if [ $gradchan -gt 3 ]; then
    gradchan=3
  fi
  if [ $gradchan -lt -3 ]; then
    gradchan=-3
  fi
fi
if [ $debug -gt 0 ]; then
  if [ $gradchan -eq 0 ]; then
    echo "This sequence uses $channels r.f. channels"
  elif [ $gradchan -eq 1 ]; then
    echo "This sequence uses $rfchan r.f. and 1 gradient channels"
  else
    echo "This sequence uses $rfchan r.f. and $gradchan gradient channels"
  fi
fi


# +----------------------------------------------------+
# | 2nd NAWK pass: check whether oph is being modified |
# +----------------------------------------------------+
ophmod=`cat "$source" | nawk '
  BEGIN { mod = 0 }
  {
    if (((($2 == "incr") || ($2 == "decr")) && ($6 == "oph")) ||
        ((($2 == "hlv")  || ($2 == "dbl")  || ($2 == "mod2") ||
          ($2 == "mod4") || ($2 == "assign")) && ($8 == "oph")) ||
        ((($2 == "add")  || ($2 == "sub")  || ($2 == "mult") ||
	  ($2 == "divn") || ($2 == "modn") || ($2 == "getelem")) &&
         ($10 == "oph")) ||
        ($2 == "setreceiver"))
      mod=1
  }
  END {print mod}'`
if [ $ophmod -ne 0 -a $debug -gt 0 ]; then
  echo "oph is modified in this sequence"
fi


# +-----------------------------------------------------------+
# | 3rd NAWK pass: check whether sequence is 2D/nD experiment |
# +-----------------------------------------------------------+
nDexp=`cat "$source" | nawk '
  BEGIN {nD=0}
  {
    if ((NF > 5) && ($1 == 912) &&
        (($5 == "ni") || ($5 == "ni2") || ($5 == "ni3")))
      nD=1
  }
  END {print nD}'`
if [ $debug -gt 0 ]; then
  if [ $nDexp -gt 0 ]; then
    echo "nD sequence"
  else
    echo "Not an nD sequence"
  fi
fi


# +------------------------------------------------+
# | For nD experiments change d2/d3/d4 to t1/t2/t3 |
# +------------------------------------------------+
if [ $nDexp -gt 0 ]; then
  cat "$source" | sed 's/ d2 / t1 /g
s/ d2+/ t1+/g
s/ d2-/ t1-/g
s/ d2\*/ t1*/g
s/ d2\// t1\//g
s/(d2+/(t1+/g
s/(d2-/(t1-/g
s/(d2\*/(t1*/g
s/(d2\//(t1\//g
s/+d2 /+t1 /g
s/-d2 /-t1 /g
s/\*d2 /*t1 /g
s/+d2)/+t1)/g
s/-d2)/-t1)/g
s/\*d2)/*t1)/g
s/\*d2+/*t1+/g
s/\*d2-/*t1-/g
s/+d2+/+t1+/g
s/+d2-/+t1-/g
s/+d2\*/+t1*/g
s/+d2\//+t1\//g
s/-d2+/-t1+/g
s/-d2-/-t1-/g
s/-d2\*/-t1*/g
s/-d2\//-t1\//g
s/ d3 / t2 /g
s/ d3+/ t2+/g
s/ d3-/ t2-/g
s/ d3\*/ t2*/g
s/ d3\// t2\//g
s/(d3+/(t2+/g
s/(d3-/(t2-/g
s/(d3\*/(t2*/g
s/(d3\//(t2\//g
s/+d3 /+t2 /g
s/-d3 /-t2 /g
s/\*d3 /*t2 /g
s/+d3)/+t2)/g
s/-d3)/-t2)/g
s/\*d3)/*t2)/g
s/\*d3+/*t2+/g
s/\*d3-/*t2-/g
s/+d3+/+t2+/g
s/+d3-/+t2-/g
s/+d3\*/+t2*/g
s/+d3\//+t2\//g
s/-d3+/-t2+/g
s/-d3-/-t2-/g
s/-d3\*/-t2*/g
s/-d3\//-t2\//g
s/ d4 / t3 /g
s/ d4+/ t3+/g
s/ d4-/ t3-/g
s/ d4\*/ t3*/g
s/ d4\// t3\//g
s/(d4+/(t3+/g
s/(d4-/(t3-/g
s/(d4\*/(t3*/g
s/(d4\//(t3\//g
s/+d4 /+t3 /g
s/-d4 /-t3 /g
s/\*d4 /*t3 /g
s/+d4)/+t3)/g
s/-d4)/-t3)/g
s/\*d4)/*t3)/g
s/\*d4+/*t3+/g
s/\*d4-/*t3-/g
s/+d4+/+t3+/g
s/+d4-/+t3-/g
s/+d4\*/+t3*/g
s/+d4\//+t3\//g
s/-d4+/-t3+/g
s/-d4-/-t3-/g
s/-d4\*/-t3*/g
s/-d4\//-t3\//g' > "$source".tmp

  if [ $debug -gt 0 ]; then
    if [ `diff "$source" "$source".tmp | wc -l` -gt 0 ]; then
      wc "$source" "$source".tmp 2> /dev/null
      echo "Translated d2/d3/d4 into t1/t2/t3:"
      diff "$source" "$source".tmp
      echo ""
    elif [ $gradchan -ge 0 ]; then
      echo "No occurrences of d2/d3/d4 translated into t1/t2/t3"
    fi
  fi
  if [ `diff "$source" "$source".tmp | wc -l` -gt 0 ]; then
    source="$source".tmp
  else
    rm -f "$source".tmp
  fi
fi


# +----------------------------------------------------------------+
# | reset/remove temporary/intermediate files used/generated below |
# +----------------------------------------------------------------+
ff_tmptarget="$target".ff_tmp
ee_tmptarget="$target".ee_tmp
ee_tmptarget0="$target".ee_tmp0
phstarget="$target".phs
rm -f "$ff_tmptarget" "$ee_tmptarget" "$ee_tmptarget0" "$phstarget"

if [ $debug -gt 0 ]; then
  echo ""
  echo "DPS INPUT FILE:"
  echo "#######################################\c"
  echo "#######################################"
  cat "$source"
  echo ""
fi


# +-----------------------------------------------------+
# |   Main sed -> NAWK pass 4: Now Do the Conversion -  |
# +-----------------------------------------------------+
# | Eliminate rof1/rof2 and AP bus timing corrections   |
# |    from C code (now doing AP stuff inside delays!). |
# | Also, use PI instead of M_PI and numeric values.    |
# | Remove unnecessary numeric precision in expressions |
# |    to make expressions more readable.               |
# +-----------------------------------------------------+
# | To facilitate the correlation with the table input  |
# | substitute first token with line number unless line |
# | is empty or starts with " 9". The first field is    |
# | used otherwise within vnmr2sc.                      |
# +-----------------------------------------------------+

cat "$source" | nawk '{
  if ((NF > 0) && (substr($0,1,2) != " 9"))
    $1 = NR
  print
}' | grep -v '^ 9' | sed 's/\.0[0]*+/+/g
s/\.0[0]*-/-/g
s/\.0[0]*\*/*/g
s/\.0[0]*\//\//g
s/\.0[0]*)/)/g
s/\.0[0]* / /g
s/\.0[0]*e/e/g
s/[+-]rof1\*2//g
s/[+-]rof1//g
s/[+-]2\*rof1//g
s/[+-]rof2//g
s/[+-][1-9][0-9]*e-6//g
s/[+-][0-9][0-9]*\.[0-9]*e-6//g
s/[+-]POWER_DELAY\*2//g
s/[+-]POWER_DELAY//g
s/[+-]2\*POWER_DELAY//g
s/[+-]PWRF_DELAY\*2//g
s/[+-]PWRF_DELAY//g
s/[+-]2\*PWRF_DELAY//g
s/[+-]SAPS_DELAY\*2//g
s/[+-]SAPS_DELAY//g
s/[+-]2\*SAPS_DELAY//g
s/[+-]OFFSET_DELAY\*2//g
s/[+-]OFFSET_DELAY//g
s/[+-]2\*OFFSET_DELAY//g
s/[+-]OFFSET_LTCH_DELAY\*2//g
s/[+-]OFFSET_LTCH_DELAY//g
s/[+-]2\*OFFSET_LTCH_DELAY//g
s/[+-]WFG_START_DELAY\*2//g
s/[+-]WFG_START_DELAY//g
s/[+-]2\*WFG_START_DELAY//g
s/[+-]WFG_STOP_DELAY\*2//g
s/[+-]WFG_STOP_DELAY//g
s/[+-]2\*WFG_STOP_DELAY//g
s/[+-]WFG2_START_DELAY\*2//g
s/[+-]WFG2_START_DELAY//g
s/[+-]2\*WFG2_START_DELAY//g
s/[+-]WFG2_STOP_DELAY\*2//g
s/[+-]WFG2_STOP_DELAY//g
s/[+-]2\*WFG2_STOP_DELAY//g
s/[+-]WFG3_START_DELAY\*2//g
s/[+-]WFG3_START_DELAY//g
s/[+-]2\*WFG3_START_DELAY//g
s/[+-]WFG3_STOP_DELAY\*2//g
s/[+-]WFG3_STOP_DELAY//g
s/[+-]2\*WFG3_STOP_DELAY//g
s/[+-]PRG_START_DELAY\*2//g
s/[+-]PRG_START_DELAY//g
s/[+-]2\*PRG_START_DELAY//g
s/[+-]PRG_STOP_DELAY\*2//g
s/[+-]PRG_STOP_DELAY//g
s/[+-]2\*PRG_STOP_DELAY//g
s/[+-]SPNLK_START_DELAY\*2//g
s/[+-]SPNLK_START_DELAY//g
s/[+-]2\*SPNLK_START_DELAY//g
s/[+-]SPNLK_STOP_DELAY\*2//g
s/[+-]SPNLK_STOP_DELAY//g
s/[+-]2\*SPNLK_STOP_DELAY//g
s/[+-]VAGRADIENT_DELAY\*2//g
s/[+-]VAGRADIENT_DELAY//g
s/[+-]2\*VAGRADIENT_DELAY//g
s/[+-]OBLIQUEGRADIENT_DELAY\*2//g
s/[+-]OBLIQUEGRADIENT_DELAY//g
s/[+-]2\*OBLIQUEGRADIENT_DELAY//g
s/[+-]GRADIENT_DELAY\*2//g
s/[+-]GRADIENT_DELAY//g
s/[+-]2\*GRADIENT_DELAY//g
s/[+-]ACQUIRE_START_DELAY\*2//g
s/[+-]ACQUIRE_START_DELAY//g
s/[+-]2\*ACQUIRE_START_DELAY//g
s/[+-]ACQUIRE_STOP_DELAY\*2//g
s/[+-]ACQUIRE_STOP_DELAY//g
s/[+-]2\*ACQUIRE_STOP_DELAY//g
s/[+-]SETDECMOD_DELAY\*2//g
s/[+-]SETDECMOD_DELAY//g
s/[+-]2\*SETDECMOD_DELAY//g
s/[+-]DECMODFREQ_DELAY\*2//g
s/[+-]DECMODFREQ_DELAY//g
s/[+-]2\*DECMODFREQ_DELAY//g
s/3\.14159/PI/g
s/3\.1416/PI/g
s/3\.14/PI/g
s/\*M_PI/*PI/g
s/M_PI\*/PI*/g
s/\/M_PI/\/PI/g
s/M_PI\//PI\//g' | nawk '

# +----------------------------------------+
# | ====================================== |
# | HEADER: channel and global definitions |
# | ====================================== |
# +----------------------------------------+
BEGIN {
  debug = 0 + '$debug'		# debugging flag
  logfile = "'$logfile'"	# log file, used for debugging mode only

  dotables = 0 + '$dotables'	# flag for full conversion of phase tables
  tblfile = "'$tbltarget'"	# file with phase tables

  id = 1                # running element id
  lid = 0               # local value of element id
  idAt = 0              # main line docking point

  # variables used for preparing chain of elements docked front-to-front
  #     inside another element (delay or pulse) yet to be defined
  ff_pend_Id = 1        # id of element that will carry pending elements
  ff_pend_elems = 0     # number of pending elements
  ff_pend_idAt = 0      # docking point for pending elements

  # variables used for preparing chain of elements docked end-to-end
  #     inside an element (delay or pulse) that is already defined
  ee_pend_Id = 1        # id of element that will carry pending elements
  ee_pend_elems = 0     # number of pending elements
  ee_pend_idAt = 0      # docking point for pending elements

  was_delay = -1        # flag indicating whether last element was delay
                        # (gradient pulses are treated as delay)
                        # -1: start, 0: pulse, 1: delay

  # if(zero)/else(nz) "hooks" - need to remember docking point for
  # the else branch and for the elements after the endif
  for (i = 1; i <= 5; i++)
    ifId[i] = 0
  iflevel = 0           # real-time if index (level indicator)

  # loop "hooks" - need to remember docking point for the
  #                elements after endloop
  for (i = 1; i <= 5; i++)
    loopId[i] = 0
  looplevel = 0		# loop index / level indicator (softloops & hardloop)

  channel = 1           # channel index
  rfchans = 0           # r.f. channel count
  gradch = 1            # gradient channel index (currently 1 only)
  acquire = 0           # flag for explicit acquisition
  status = 0            # flag for use of status commands in C sequence
  c_dockAt = "end"      # current dock-to point (used with ifs and loops)
  lastgradch = 0
  lastrfch = '$channels'	# number of channels as defined above
  lastgradch = '$gradchan'	# number of gradient channels as defined above
  if (lastgradch < 0)   # this is for channel number specified in argument
  {
    lastgradch *= -1
    imaging = 1
  }
  else
    imaging = 0
  ophmod = '$ophmod'    # flag indicating whether oph has been modified

  # +-------------------+
  # | phase table usage |
  # +-------------------+
  ph0 = 0; ph90 = 0; ph180 = 0; ph270 = 0
  phct = 0; phoph = 0
  ophn = ""
  for (i = 1; i <= 14; i++)
  {
    phv[i] = 0                  # flags for v variables (variable!)
    phvn[i] = ""                # SpinCAD table names used instead
  }
  for (i = 1; i <= 60; i++)
  {
    pht[i] = 0                  # flags for tables (fixed)
    phtn[i] = ""                # SpinCAD table names used instead
  }
  phxcount = 0
  lastphx=64
  for (i = 1; i <= lastphx; i++)
  {
    phx[i] = 0                  # flags for "other" C phase placeholders
    phxs[i] = ""		# names used in C code
    phxn[i] = ""                # SpinCAD table names used instead
  }
  for (i = 1; i <= 256; i++)
    ph[i] = 0                   # flags for new SpinCAD phases
  scph = 0                      # SpinCAD phase index (ph1 .. ph256)
  phasecount=0

  # initialize channel-specific "bookkeeking" variables
  for (i = 1; i <= lastrfch; i++)
  {
    stepsiz[i] = 90		# small-angle phaseshift stepsize
    chsaps[i] = ""		# current small-angle phaseshift
    setpower[i] = 0		# flag for power changes
    setpower_if[i] = 0		# flag for power changes (conditional-if)
    setpower_el[i] = 0		# flag for power changes (conditional-else)
    powerval[i] = ""		# current power value
    powerval_c[i] = ""		# current power value (conditional)
  }

  # delay units for "incdelay" calls
  delay1=""
  delay2=""
  delay3=""
  delay4=""
  delay5=""

  # +------------------------------------------------+
  # | start pulse sequence file with XML header line |
  # +------------------------------------------------+
  if (debug > 0)
    printf("Starting with XML header line\n") >> logfile
  printf("<spincadSequence>\n")

  # +------------------------------+
  # | add r.f. channel definitions |
  # +------------------------------+
  file = "'$library'/channelrf"
  while (channel <= lastrfch)
  {
    if (debug > 0)
      printf("           channel %d (r.f.)\n", channel) >> logfile

    while ((getline < file) > 0)
    {
      print
      if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", channel)
      }
      else if ($1 == "<label>")
      {
        getline < file
        if (channel == 1)
          printf("   r.f. Channel #1 / Observe\n")
        else
          printf("   r.f. Channel #%d / Decoupler #%d\n", channel, channel - 1)
      }
    }
    close(file)
    channel++
    rfchans++
  }

  # +----------------------------------+
  # | add gradient channel definitions |
  # +----------------------------------+
  file = "'$library'/channelgrad"
  while (gradch <= lastgradch)
  {
    if (debug > 0)
      printf("           channel %d (gradient)\n", channel) >> logfile

    while ((getline < file) > 0)
    {
      print
      if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", channel)
      }
      else if ($1 == "<label>")
      {
        getline < file
        if (imaging == 0)
        {
          if (gradch == 1)
            printf("   Z Gradient\n")
          else if (gradch == 2)
            printf("   X Gradient\n")
          else
            printf("   Y Gradient\n")
        }
        else
        {
          if (gradch == 1)
            printf("   Readout Gradient\n")
          else if (gradch == 2)
            printf("   Phase Encoding Gradient\n")
          else
            printf("   Slice Selection Gradient\n")
        }
      }
      else if ($1 == "<axis>")
      {
        getline < file
        if (imaging == 0)
        {
          if (gradch == 1)
            printf("   z\n")
          else if (gradch == 2)
            printf("   x\n")
          else
            printf("   y\n")
        }
	else
        {
	  # imaging gradient orientation is PRELIMINARY
          if (gradch == 1)
            printf("   z\n")
          else if (gradch == 2)
            printf("   x\n")
          else
            printf("   y\n")
        }
      }
    }
    close(file)
    channel++
    gradch++
  }
}

# +-------------------------------------+
# | =================================== |
# | BODY: translate dps code to SpinCAD |
# | =================================== |
# +-------------------------------------+
{

  # +-----------------------------------------+
  # | skip lines that do not need translation |
  # |   (such as phase math etc.)             |
  # +-----------------------------------------+
  while ((NF > 1) &&
	 (($2 == "getelem") || ($2 == "setreceiver") ||
          ($2 == "assign")  || ($2 == "initval") ||
 	  ($2 == "incr")    || ($2 == "decr")    ||
          ($2 == "add")     || ($2 == "sub")     ||
 	  ($2 == "hlv")     || ($2 == "dbl")     ||
          ($2 == "mod2")    || ($2 == "mod4")    ||
	  ($2 == "modn")    || ($2 == "mult")    ||
          ($2 == "divn")    ||
          ($2 == "tsadd")   || ($2 == "tssub")   ||
          ($2 == "tsmult")  || ($2 == "tsdiv")   ||
          ($2 == "ttadd")   || ($2 == "ttsub")   ||
          ($2 == "ttmult")  || ($2 == "ttdiv")   ||
	  ($2 == "setautoincrement") || ($2 == "setdivnfactor") ||
	  ($2 == "obsstepsize")      || ($2 == "decstepsize")   ||
	  ($2 == "dec2stepsize")     || ($2 == "dec3stepsize")  ||
	  ($2 == "stepsize")))
  {
    if (debug > 0)
      printf("skip:   %s\n",$0) >> logfile

    # +--------------------------------------------------+
    # | mark calculated phase variables as fresh/reset   |
    # |   (assign new SpinCAD phase when used next time) |
    # +--------------------------------------------------+
    if (($2 == "incr") || ($2 == "decr"))
      resetphase($6);
    else if (($2 == "assign") || ($2 == "hlv") || ($2 == "dbl") ||
	     ($2 == "mod2") || ($2 == "mod4"))
      resetphase($8)
    else if (($2 == "getelem") || ($2 == "add") || ($2 == "sub") ||
	     ($2 == "modn") || ($2 == "mult") || ($2 == "divn"))
      resetphase($10)
    else if (($2 == "obsstepsize")  || ($2 == "decstepsize")  ||
             ($2 == "dec2stepsize") || ($2 == "dec3stepsize") ||
             ($2 == "stepsize"))
      stepsiz[$3] = $6
    else if ($2 == "setreceiver")
      resetphase("oph")

    # skip to next line
    getline
  }



  # +-----------------+
  # | =============== |
  # | PULSES & DELAYS |
  # | =============== |
  # +-----------------+

  # +------------------------------------------------------------+
  # | obspulse / pulse / rgpulse / iobspulse / ipulse / irgpulse |
  # | decpulse / decrgpulse / idecpulse / idecrgulse             |
  # | dec2pulse / dec2rgpulse / idec2pulse / idec2rgpulse        |
  # | dec3pulse / dec3rgpulse / idec3pulse / idec3rgpulse        |
  # | dec4pulse / dec4rgpulse / idec4pulse / idec4rgpulse        |
  # | genpulse / genrgpulse                                      |
  # +------------------------------------------------------------+
  if (($2 == "obspulse")   || ($2 == "iobspulse")    ||
      ($2 == "pulse")      || ($2 == "rgpulse")      ||
      ($2 == "ipulse")     || ($2 == "irgpulse")     ||
      ($2 == "decpulse")   || ($2 == "decrgpulse")   ||
      ($2 == "idecpulse")  || ($2 == "idecrgpulse")  ||
      ($2 == "dec2pulse")  || ($2 == "dec2rgpulse")  ||
      ($2 == "idec2pulse") || ($2 == "idec2rgpulse") ||
      ($2 == "dec3pulse")  || ($2 == "dec3rgpulse")  ||
      ($2 == "idec3pulse") || ($2 == "idec3rgpulse") ||
      ($2 == "dec4pulse")  || ($2 == "dec4rgpulse")  ||
      ($2 == "idec4pulse") || ($2 == "idec4rgpulse") ||
      ($2 == "genpulse")   || ($2 == "genrgpulse")   ||
      ($2 == "simpulse")   || ($2 == "sim3pulse")    ||
      ($2 == "sim4pulse")  || ($2 == "gensim2pulse") ||
      ($2 == "gensim3pulse"))
  {
    # set delay flag
    was_delay = 0
    npulses = 0

    # capture relevant parts of line
    linenum = $1
    predly = $7
    if (($14 != "0.0") && ($14 != "0"))
    {
      npulses++
      chan[npulses] = $11
      phas[npulses] = $12
      pw[npulses] = $14
    }
    # simpulses with at least 2 pulses
    if ((substr($2,1,3) == "sim") || (substr($2,1,6) == "gensim"))
    {
      if (($19 != "0.0") && ($19 != "0"))
      {
        npulses++
        chan[npulses] = $16
        phas[npulses] = $17
        pw[npulses] = $19
      }
    }
    # simpulses with at least 3 pulses
    if (($2 == "sim3pulse") || ($2 == "sim4pulse") ||
        ($2 == "gensim3pulse"))
    {
      if (($24 != "0.0") && ($24 != "0"))
      {
        npulses++
        chan[npulses] = $21
        phas[npulses] = $22
        pw[npulses] = $24
      }
    }
    # simpulses with at 4 pulses
    if ($2 == "sim4pulse")
    {
      if (($29 != "0.0") && ($29 != "0"))
      {
        npulses++
        chan[npulses] = $26
        phas[npulses] = $27
        pw[npulses] = $29
      }
    }
    # must have at least 1 pulse!
    if (npulses == 0)
    {
      npulses = 1
      chan[npulses] = $11
      phas[npulses] = $12
      pw[npulses] = $14
    }

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # remember the current ID
    #    if there are defined elements docked front-to-front to this one
    if (ff_pend_elems > 0)
    {
      tmpId = id
      id = ff_pend_Id
    }

    # try setting power on first pulse after a power setting element;
    # this way it is less likely that power settings are forgotten when
    # cleaning up a converted sequence
    for (p = 1; p <= npulses; p++)
    {
      ch = chan[p]
      if ((iflevel == 0) && (setpower[ch] == 1))
      {  
        power[p] = powerval[ch]
        setpower[ch] = 0
      }  
      else if ((iflevel > 0) && (setpower_if[ch] == 1))
      {  
        power[p] = powerval_c[ch]
        setpower_if[ch] = 0
      }  
      else if ((iflevel > 0) && (setpower_el[ch] == 1))
      {  
        power[p] = powerval_c[ch]
        setpower_el[ch] = 0
      }  
      else
        power[p] = "Unaltered"
    }

    # NOW add the new SpinCAD element
    # --------------------------------------------------------------------
    addPulse(id, pw[1], predly, phas[1], power[1], chan[1],
	     "front", idAt, c_dockAt, linenum, 1)
    c_dockAt = "end"
    idAt = id

    # deal with elements docked front-to-front into the current event
    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }

    # For simpulses add extra pulses now!
    # -----------------------------------
    for (p = 2; p <= npulses; p++)
    {
      addPulse(id, pw[p], predly, phas[p], power[p], chan[p],
	       "mid", idAt, "mid", linenum, p)
      id++
    }
  }


  # +-----------------------------------------+
  # | shaped_pulse / decshaped_pulse /        |
  # | shapedpulse / decshapedpulse /          |
  # | dec2shaped_pulse / dec3shaped_pulse /   |
  # | genshaped_pulse / gen_apshaped_pulse /  |
  # | apshaped_pulse / apshaped_decpulse /    |
  # | apshaped_dec2pulse / apshaped_dec3pulse |
  # | simshaped_pulse / sim3shaped_pulse      |
  # | gensim3shaped_pulse / simshapedpulse    |
  # +-----------------------------------------+
  if (($2 == "shaped_pulse")       || ($2 == "simshapedpulse")     ||
      ($2 == "shapedpulse")        || ($2 == "decshapedpulse")     ||
      ($2 == "decshaped_pulse")    || ($2 == "dec2shaped_pulse")   ||
      ($2 == "dec3shaped_pulse")   || ($2 == "genshaped_pulse")    ||
      ($2 == "apshaped_pulse")     || ($2 == "apshaped_decpulse")  ||
      ($2 == "apshaped_dec2pulse") || ($2 == "apshaped_dec3pulse") ||
      ($2 == "gen_apshaped_pulse") || ($2 == "simshaped_pulse")    ||
      ($2 == "sim3shaped_pulse")   || ($2 == "gensim3shaped_pulse"))
  {
    # set delay flag
    was_delay = 0
    npulses = 0

    # capture relevant parts of line
    linenum = $1
    predly = $7
    if (($14 != "0.0") && ($14 != "0"))
    {
      npulses++
      chan[npulses] = $11
      shap[npulses] = $12
      phas[npulses] = $13
      pw[npulses] = $15
    }
    # simpulses with at least 2 pulses
    if ((substr($2,1,3) == "sim") || (substr($2,1,6) == "gensim"))
    {
      if (($21 != "0.0") && ($21 != "0"))
      {
        npulses++
        chan[npulses] = $17
        shap[npulses] = $18
        phas[npulses] = $19
        pw[npulses] = $21
      }
    }
    # simpulses with at least 3 pulses
    if ($2 == "sim3shaped_pulse")
    {
      if (($27 != "0.0") && ($27 != "0"))
      {
        npulses++
        chan[npulses] = $23
        shap[npulses] = $24
        phas[npulses] = $25
        pw[npulses] = $27
      }
    }
    # must have at least 1 pulse!
    if (npulses == 0)
    {
      npulses = 1
      chan[npulses] = $11
      shap[npulses] = $12
      phas[npulses] = $13
      pw[npulses] = $15
    }

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # remember the current ID
    #    if there are defined elements docked front-to-front to this one
    if (ff_pend_elems > 0)
    {
      tmpId = id
      id = ff_pend_Id
    }

    # try setting power on first pulse after a power setting element; 
    # this way it is less likely that power settings are forgotten when 
    # cleaning up a converted sequence
    for (p = 1; p <= npulses; p++)
    {
      ch = chan[p]
      if ((iflevel == 0) && (setpower[ch] == 1))
      {  
        power[p] = powerval[ch]
        setpower[ch] = 0
      }  
      else if ((iflevel > 0) && (setpower_if[ch] == 1))
      {  
        power[p] = powerval_c[ch]
        setpower_if[ch] = 0
      }  
      else if ((iflevel > 0) && (setpower_el[ch] == 1))
      {  
        power[p] = powerval_c[ch]
        setpower_el[ch] = 0
      }  
      else
        power[p] = "Unaltered"
    }

    # NOW add the new SpinCAD element
    # -----------------------------------------------------------------------
    if (shap[1] == "?")
      addPulse(id, pw[1], predly, phas[1], power[1], chan[1],
	       "front", idAt, c_dockAt, linenum, 1)
    else
      addShapedPulse(id, shap[1], pw[1], predly, phas[1], power[1], chan[1],
		"front", idAt, c_dockAt, linenum, 1)
    c_dockAt = "end"
    idAt = id

    # deal with elements docked front-to-front into the current event
    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }

    # For sim(shaped)pulses add extra pulses now!
    # -------------------------------------------
    for (p = 2; p <= npulses; p++)
    {
      if (shap[p] == "?")
        addPulse(id, pw[p], predly, phas[p], power[p], chan[p],
	         "mid", idAt, "mid", linenum, p)
      else
        addShapedPulse(id, shap[p], pw[p], predly, phas[p], power[1], chan[p],
		"mid", idAt, "mid", linenum, p)
      id++
    }
  }


  # +------------+
  # | zgradpulse |
  # +------------+
  else if ($2 == "zgradpulse")
  {
    # set delay flag
    was_delay = 1

    # capture relevant parts of line
    duration = $7
    level = $9
    levelvalue=$10
    coh_selector="None"
    if (substr(level,1,7) == "icosel*")
    {
      level = substr(level,8,length(level)-7)
      coh_selector="t1"
    }
    if (substr(level,length(level)-6,7) == "*icosel")
    {
      level = substr(level,1,length(level)-7)
      coh_selector="t1"
    }

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # remember the current ID
    #    if there are defined elements docked front-to-front to this one
    if (ff_pend_elems > 0)
    {
      tmpId = id
      lid = ff_pend_Id
    }
    else
      lid = id

    if (debug > 0)
      printf("%2d->%2d f%s (gradpulse)\n",
	     lid, idAt, substr(c_dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/gradpulse"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", lid)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        printf("   %s\n", duration)
      }
      else if ($1 == "<attr2>")
      {
        getline < file
        printf("   %s\n", level)
      }
      else if ($1 == "<attr4>")
      {
        getline < file
        printf("   %s\n", coh_selector)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", c_dockAt)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", rfchans + 1)
      }
    }
    close(file)
    c_dockAt = "end"
    idAt = lid

    # deal with elements docked front-to-front into the current event
    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }
  }


  # +-----------+
  # | initdelay |
  # +-----------+
  else if ($2 == "initdelay")
  {
    if ($6 == "DELAY1")
      delay1 = "" $8
    else if ($6 == "DELAY2")
      delay2 = "" $8
    else if ($6 == "DELAY3")
      delay3 = "" $8
    else if ($6 == "DELAY4")
      delay4 = "" $8
    else if ($6 == "DELAY5")
      delay5 = "" $8

    if (debug > 0)
      printf("          (initdelay: %s = %s)\n", $6, $8) >> logfile
  }


  # +------------------------------------------------------------+
  # | delay / idelay / hsdelay / statusdelay / incdelay / vdelay |
  # +------------------------------------------------------------+
  else if (($2 == "delay") || ($2 == "hsdelay") || ($2 == "idelay") ||
           (($3 == 1) && ($2 == "statusdelay")) ||
	   ($2 == "incdelay") || ($2 == "vdelay"))
  {
    # set delay flag
    was_delay = 1

    # capture relevant parts of line
    linenum = $1
    funcname = $2
    if ($2 == "incdelay")
    {
      # for incdelays, construct simple delay with duration
      # attribute such as "ph1*(value of initialized delay unit)"
      if ($8 == "DELAY1")
        duration = "" checkphase($6, linenum, 1, 1) "*" delay1
      else if ($8 == "DELAY2")
        duration = "" checkphase($6, linenum, 1, 1) "*" delay2
      else if ($8 == "DELAY3")
        duration = "" checkphase($6, linenum, 1, 1) "*" delay3
      else if ($8 == "DELAY4")
        duration = "" checkphase($6, linenum, 1, 1) "*" delay4
      else if ($8 == "DELAY5")
        duration = "" checkphase($6, linenum, 1, 1) "*" delay5
      else
	duration = ""
    }
    else if ($2 == "vdelay")
    {
      # for vdelays, construct simple delay with duration
      # attribute such as "ph1*(timing unit value)"
      if ($8 == "NSEC")
	duration = "" checkphase($6, linenum, 1, 1) "*25e-9+0.1e-6"
      else if ($8 == "USEC")
	duration = "" checkphase($6, linenum, 1, 1) "*1e-6"
      else if ($8 == "MSEC")
	duration = "" checkphase($6, linenum, 1, 1) "*1e-3"
      else # if ($8 == "SEC")
	duration = "" checkphase($6, linenum, 1, 1) "*1.0"
    }
    else
      duration = $6
    dlen = 50       # standard display width

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # remember the current ID
    #    if there are defined elements docked front-to-front to this one
    if (ff_pend_elems > 0)
    {
      tmpId = id
      lid = ff_pend_Id
    }
    else
      lid = id

    if (debug > 0)
      printf("%2d->%2d f%s (%s)\n",
	     lid, idAt, substr(c_dockAt,1,1), funcname) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/delay"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", lid)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        printf("   %s\n", duration)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", c_dockAt)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   1\n")
      }
      else if ($1 == "<len>")
      {
        getline < file
        # scale up displayed width for "long" delays
        if      ((duration == "d1") || (duration ~ /d1-/))
          printf("   %d\n", 3*dlen)
        else if ((duration == "satdelay") || (duration == "presat"))
          printf("   %d\n", 2*dlen)
        else
          printf("   %d\n", dlen)
      }
    }
    close(file)
    c_dockAt = "end"
    idAt = lid

    # +--------------------------------+
    # | for hsdelay add homospoil part |
    # +--------------------------------+
    if (funcname == "hsdelay")
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        id++
        ff_pend_Id = lid
        ff_pend_idAt = lid
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt

      # try not to place homospoil stuff on channel #1
      #    (use first gradiuent channel, if present / defined)
      l_chanId = rfchans
      if (lastgradch > 0)
        l_chanId++

      # +----------------------------+
      # | add true-only IF composite |
      # +----------------------------+
      if (debug > 0)
        printf("%2d->%2d f%s (if_true)\n",
                id, l_idAt, substr(dockAt,1,1)) >> logfile

      file = "'$library'/if"
      while ((getline < file) > 0)
      { 
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<attr1>")
        {
          getline < file
          printf("   NOT USED\n") >> tmpfile
        }
        else if ($1 == "<attr2>")
        {
          getline < file
          printf("   (yflag(hs,%d)) && (hst <= (%s))\n",
		statusIndex, duration) >> tmpfile
        }
        else if ($1 == "<attr3>")
        {
          getline < file
          printf("   True\n") >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   %s\n", dockAt) >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", l_chanId) >> tmpfile
        }
        else if ($1 == "<len>")
        {
          getline < file
          printf("   25\n") >> tmpfile
        }
      }
      close(file)
      l_idAt = id
      id++

      # +------------------------+
      # | actual homospoil pulse |
      # +------------------------+
      if (debug > 0)
        printf("%2d->%2d ft (delay)\n", id, l_idAt) >> logfile

      file = "'$library'/delay" 
      while ((getline < file) > 0) 
      {   
        print >> tmpfile 
        if ($1 == "<id>")
        { 
          getline < file 
          printf("   %d\n", id) >> tmpfile 
        } 
        else if ($1 == "<attr1>") 
        { 
          getline < file 
          printf("   hst\n") >> tmpfile 
        } 
        else if ($1 == "<dock>") 
        {
          getline < file 
          printf("   front\n") >> tmpfile 
        } 
        else if ($1 == "<idAt>") 
        { 
          getline < file 
          printf("   %d\n", l_idAt) >> tmpfile 
        } 
        else if ($1 == "<dockAt>") 
        { 
          getline < file 
          printf("   true\n") >> tmpfile 
        } 
        else if ($1 == "<chanId>") 
        { 
          getline < file 
          printf("   %d\n", l_chanId) >> tmpfile
        } 
        else if ($1 == "<len>")
        {
          getline < file
          printf("   20\n") >> tmpfile
        }
      }   
      close(file) 
      l_idAt = id 
      id++ 

      # +---------------------+ 
      # | switch homospoil on |
      # +---------------------+
      if (debug > 0)
        printf("%2d->%2d ff (hsOn)\n", id, l_idAt) >> logfile

      file = "'$library'/psgHomospoil"
      while ((getline < file) > 0)
      {  
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<state>")
        {
          getline < file
          printf("   On\n") >> tmpfile
        }
        else if ($1 == "<dock>") 
        {
          getline < file 
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>") 
        {
          getline < file 
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file 
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file 
          printf("   %d\n", l_chanId) >> tmpfile
        }
      }  
      close(file)
      id++

      # +----------------------+
      # | switch homospoil off |
      # +----------------------+
      if (debug > 0)
        printf("%2d->%2d ee (hsOn)\n", id, l_idAt) >> logfile

      file = "'$library'/psgHomospoil"
      while ((getline < file) > 0)
      {  
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<state>")
        {
          getline < file
          printf("   Off\n") >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   end\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   end\n") >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", l_chanId) >> tmpfile
        }
      }  
      close(file)
      close(tmpfile)

      ff_pend_elems += 4
      ff_pend_idAt = id
      id++

      tmpId = id
      id = lid
    }

    # deal with elements docked front-to-front into the current event
    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }
  }


  # +--------------------------------------------------------------------+
  # | spinlock / decspinlock / dec2spinlock / dec3spinlock / genspinlock |
  # +--------------------------------------------------------------------+
  if (($2 == "spinlock")     || ($2 == "decspinlock")  ||
      ($2 == "dec2spinlock") || ($2 == "dec3spinlock") ||
      ($2 == "genspinlock"))
  {
    # set delay flag
    was_delay = -1

    # capture relevant parts of line
    linenum = $1
    channel = $3
    pattern = $6
    cycles = $10		# (cannot be used, see below)
    pw90 = $12
    dres = $14			# (not used)
    phase = "" checkphase($8, linenum, 1, 90)

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # deal with elements that were intended to be docked
    # front-to-front into the next event - we need to
    # deal with this prior to starting the spinlock
    if (ff_pend_elems > 0)
    {
      add_ff_pending("end")
      ff_pend_elems = 0
    }

    if (debug > 0)
      printf("%2d->%2d f%s (spinlock)\n",
	     lid, idAt, substr(c_dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # --------------------------------------------------------------
    # As an exception, we leave the "duration" attribute empty;
    # the duration cannot be extracted easily from dps; the empty
    # attribute will remind the user to fill in the proper duration.
    # The sequence will only compile once this is filled in.
    file = "'$library'/spinlock"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {  
        getline < file
        printf("   %d\n", id)
      }  
      else if ($1 == "<attr1>")
      {  
        getline < file
        printf("   \n")
      }  
      else if ($1 == "<attr2>")
      {  
        getline < file
        printf("   %s\n", phase)
      }  
      else if ($1 == "<attr3>")
      {  
        getline < file
        printf("   %s\n", pw90)
      }  
      else if ($1 == "<attr5>")
      {  
        getline < file
        if (substr(pattern,1,6) == "mlev17")
          printf("   %3.1f\n", 60.0)
        else
          printf("   %3.1f\n", 0.0)
      }  
      else if ($1 == "<attr6>")
      {  
        getline < file
        if (substr(pattern,1,6) == "clmlev")
          printf("   %s\n", pw90)
        else
          print
      }  
      else if ($1 == "<dock>")
      {  
        getline < file
        printf("   front\n")
      }  
      else if ($1 == "<idAt>")
      {  
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }  
      else if ($1 == "<dockAt>")
      {  
        getline < file
        printf("   %s\n", c_dockAt)
      }  
      else if ($1 == "<chanId>")
      {  
        getline < file
        printf("   %d\n", channel)
      }  
    }  
    close(file)
    c_dockAt = "end"
    idAt = id
    id++
  }


  # +----------------------+
  # | explicit acquisition |
  # +----------------------+
  else if ($2 == "acquire")
  {
    # set delay flag
    was_delay = 0
    acquire++

    # capture relevant parts of line
    np = "" $6
    dwell = "" $8

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # remember the current ID
    #    if there are defined elements docked front-to-front to this one
    if (ff_pend_elems > 0)
    {
      tmpId = id
      lid = ff_pend_Id
    }
    else
      lid = id

    if (debug > 0)
      printf("%2d->%2d f%s (acquire)\n",
	     lid, idAt, substr(c_dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/acquire_expl"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", lid)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        printf("   %s\n", np)
      }
      else if ($1 == "<attr2>")
      {
        getline < file
        printf("   %s\n", dwell)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", c_dockAt)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   1\n")
      }
    }
    close(file)
    c_dockAt = "end"
    idAt = lid

    # deal with elements docked front-to-front into the current event
    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }
  }


  # +--------------------+
  # | ================== |
  # | CONTROL STRUCTURES |
  # | ================== |
  # +--------------------+

  # +----------------------+
  # | soft loops, hardloop |
  # +----------------------+
  else if (($2 == "loop") || ($2 == "starthardloop"))
  {
    # set delay flag
    was_delay = -1

    # capture relevant parts of line
    linenum = $1
    cycles = "" checkphase($6, linenum, 1, 1)

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # deal with elements that were intended to be docked
    # front-to-front into the next event - we need to
    # deal with this prior to starting the loop
    if (ff_pend_elems > 0)
    {
      add_ff_pending("end")
      ff_pend_elems = 0
    }

    # update loop pointers & counter
    looplevel++
    loopId[looplevel] = id

    if (debug > 0)
      printf("%2d->%2d f%s (loop)\n",
	     id, idAt, substr(c_dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/loop"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        printf("   %s\n", cycles)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", c_dockAt)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   1\n")
      }
    }
    close(file)
    idAt = id
    id++
    c_dockAt = "front"
  }


  # +--------------------------------+
  # | terminate soft loops, hardloop |
  # +--------------------------------+
  else if (($2 == "endloop") || ($2 == "endhardloop"))
  {
    # set delay flag
    was_delay = -1

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # deal with elements that were intended to be docked
    # front-to-front into the next event - we need to
    # deal with this prior to ending the loop
    if (ff_pend_elems > 0)
    {
      add_ff_pending("end")
      ff_pend_elems = 0
    }

    if (debug > 0) printf("          (endloop)\n") >> logfile

    # make next element dock to end of loop
    idAt = loopId[looplevel]
    c_dockAt = "end"
    looplevel--
  }


  # +------------------------+
  # | real-time ifs (ifzero) |
  # +------------------------+
  # skip ifzero lines at start of sequence: these are most likely
  # from real-time math only
  else if (($2 == "ifzero") && (id > 1))
  {
    # set delay flag
    was_delay = -1

    # capture relevant parts of line
    linenum = $1
    testval = "" checkphase($6, linenum, 1, 1)

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # deal with elements that were intended to be docked
    # front-to-front into the next event - we need to
    # deal with this prior to starting the if
    if (ff_pend_elems > 0)
    {
      add_ff_pending("end")
      ff_pend_elems = 0
    }

    # if there was a power change that has not been added to a pulse yet,
    # make sure it will also be added to pulses in a conditional segment
    for (i = 1; i <= lastrfch; i++)
    {
      if (setpower[i] == 1)
      {
        setpower_if[i] = 1         	# power change flag (conditional-if)
        powerval_c[i] = powerval[i]     # current power value (conditional)
      }
    }

    # update if pointers & level counter
    iflevel++
    ifId[iflevel] = id

    if (debug > 0)
      printf("%2d->%2d f%s (if)\n",
	     id, idAt, substr(c_dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/if"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        printf("   NOT USED\n")
      }
      else if ($1 == "<attr2>")
      {
        getline < file
        printf("   %s == 0\n", testval)
      }
      else if ($1 == "<attr3>")
      {
        getline < file
        printf("   Both\n")
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        if (idAt > 0)
          printf("   %d\n", idAt)
        else
          printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", c_dockAt)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   1\n")
      }
    }
    close(file)
    idAt = id
    id++
    c_dockAt = "true"
  }


  # +-----------------------------------+
  # | real-time else (elsenz) and endif |
  # +-----------------------------------+
  # suppress elsenz / endifs from real-time math
  else if ((($2 == "elsenz") || ($2 == "endif")) && (iflevel > 0))
  {
    # set delay flag
    was_delay = -1

    # capture relevant parts of line
    funcname = $2

    # deal with elements docked end-to-end into previous event
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    # deal with elements that were intended to be docked
    # front-to-front into the next event - we need to
    # deal with this prior to ending the if branch
    if (ff_pend_elems > 0)
    {
      add_ff_pending("end")
      ff_pend_elems = 0
    }

    if (debug > 0) printf("          (%s)\n", funcname) >> logfile

    # make next element dock to false branch or end of if
    if (funcname == "elsenz")
    {
      idAt = ifId[iflevel]
      c_dockAt = "false"

      # if there was a power change that has not been added to a pulse yet,
      # make sure it will also be added to pulses in a conditional segment
      for (i = 1; i <= lastrfch; i++)
      {
        if (setpower[i] == 1)
        {  
          setpower_el[i] = 1            # power change flag (conditional-else)
          powerval_c[i] = powerval[i]   # current power value (conditional)
        }  
      }
    }
    else	# (endif)
    {
      idAt = ifId[iflevel]
      c_dockAt = "end"
      iflevel--

      # return to unbranched code - reset conditional power setting flags
      if (iflevel == 0)
      {
        for (i = 1; i <= lastrfch; i++) 
        {
          setpower_if[i] = 0
          setpower_el[i] = 0
        }
      }
    }
  }


  # +---------------+
  # | ============= |
  # | GATE SETTINGS |
  # | ============= |
  # +---------------+

  # +------------------------------------------------------+
  # | xmtron / decon / dec2on / dec3on / dec4on / rfon /   |
  # | sp1on  / sp2on  / sp3on  / sp4on  / sp5on  / sp_on / |
  # | sp1off / sp2off / sp3off / sp4off / sp5off / sp_off  |
  # | lk_sample                                            |
  # |    (always performed at start of next event)         |
  # +------------------------------------------------------+
  else if (($2 == "xmtron") || ($2 == "decon")  ||
           ($2 == "dec2on") || ($2 == "dec3on") ||
  	   ($2 == "dec4on") || ($2 == "rfon")   ||
	   ($2 == "sp1on")  || ($2 == "sp1off") ||
	   ($2 == "sp2on")  || ($2 == "sp2off") ||
	   ($2 == "sp3on")  || ($2 == "sp3off") ||
	   ($2 == "sp4on")  || ($2 == "sp4off") ||
	   ($2 == "sp5on")  || ($2 == "sp5off") ||
	   ($2 == "sp_on")  || ($2 == "sp_off") ||
	   ($2 == "lk_sample"))
  {
    # capture relevant parts of line
    chanId = $3
    state = "On"
    ttlnumber = 0
    if (substr($2,1,2) == "sp")
    {
      ttlnumber = $6
      if (substr($2,length($2-1),2) == "ff")
	state = "Off"
    }

    # prepare addition of element into front-to-front docked sidechain
    tmpfile = "'$ff_tmptarget'"
    if (ff_pend_elems == 0)
    {
      if (debug > 0)
        printf("          Starting new \"ff\" chain\n") >> logfile
      ff_pend_Id = id
      ff_pend_idAt = id
      id++
      dockAt = "front"
    }
    else
    {
      dockAt = "end"
    }
    l_idAt = ff_pend_idAt

    if (debug > 0)
      printf("%2d->%2d f%s (rfon)\n",
		id, l_idAt, substr(dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    if ($2 == "lk_sample")
      file = "'$library'/psgLock"
    else if (substr($2,1,2) == "sp")
      file = "'$library'/psgSpare"
    else
      file = "'$library'/psgXmtr"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   %s\n", state) >> tmpfile
      }
      else if ($1 == "<ttlnumber>")
      {
        getline < file
        printf("   %s\n", ttlnumber) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n") >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    ff_pend_elems++
    ff_pend_idAt = id
    id++
  }


  # +------------------------------------------------------------------+
  # | xmtroff / decoff / dec2off / dec3off / dec4off / rfoff / lk_hold |
  # |    (usually performed at end of previous event)                  |
  # +------------------------------------------------------------------+
  else if (($2 == "xmtroff") || ($2 == "decoff")  ||
           ($2 == "dec2off") || ($2 == "dec3off") ||
	   ($2 == "dec4off") || ($2 == "rfoff")   ||
	   ($2 == "lk_hold"))
  {
    # capture relevant parts of line
    chanId = $3
    state="Off"

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d ee (rfoff)\n", id, idAt) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    if ($2 == "lk_hold")
      file = "'$library'/psgLock"
    else
      file = "'$library'/psgXmtr"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   %s\n", state) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay == -1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }


  # +----------------------------------------------------------+
  # | txphase / decphase / dec2phase / dec3phase / dec4phase / |
  # | xmtrphase / dcplrphase / dcplr2phase / dcplr3phase       |
  # | genqdphase / gensaphase (currently not supported by dps) |
  # |    (usually performed at end of previous event)          |
  # +----------------------------------------------------------+
  else if (($2 == "txphase") || ($2 == "decphase") ||
           ($2 == "dec2phase") || ($2 == "dec3phase") ||
	   ($2 == "dec4phase") || ($2 == "genqdphase") ||
	   ($2 == "xmtrphase") || ($2 == "dcplrphase") ||
	   ($2 == "dcplr2phase") || ($2 == "dcplr3phase") ||
	   ($2 == "dcplr4phase") || ($2 == "gensaphase"))
  {
    # capture relevant parts of line
    linenum = $1
    chanId = $3
    phs = $6
    saps = 0
    if ((substr($2,1,4) == "xmtr") || (substr($2,1,4) == "dcplr") ||
        ($2 == "gensaphase"))
    {
      phase = "" checkphase(phs, linenum, 1, stepsiz[chanId])
#     fname = "psgPhase90"
      saps = 1
      if ($6 == "zero")
	chsaps[$chanId] = ""
      else
	chsaps[$chanId] = phase
    }
    else
    {
      phase = "" checkphase(phs, linenum, 1, 90)
#     fname = "psgPhase90"
    }

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d ee (%s)\n", id, idAt, fname) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
#   if (fname == "psgPhase")
#     file = "'$library'/psgPhase"
#   else
#     file = "'$library'/psgPhase90"
    file = "'$library'/psgSetPhase"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
#     else if ($1 == "<value>")
#     {
#       getline < file
#       if (substr(phase,1,2) == "ph")
#       {
#         printf("   \"%s\"\n", phase) >> tmpfile   # use one of these 2 lines
#       # printf("   %s\n", phase) >> tmpfile	    # (this should be enough)
#       }
#       else
#         printf("   \"%s\"\n", phase) >> tmpfile
#     }
      else if ($1 == "<phaseBase>")
      {  
        getline < file
        if (substr(phase,1,2) == "ph")
        {
          printf("   \"%s\"\n", phase) >> tmpfile   # use one of these 2 lines
        # printf("   %s\n", phase) >> tmpfile       # (this should be enough)
        }
        else
          printf("   \"%s\"\n", phase) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay == -1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }


  # +--------------------------------------------------+
  # | rcvron/off, recon/off 			       |
  # |    (usually performed at end of preceding event) |
  # +--------------------------------------------------+
  else if (($2 == "recon") || ($2 == "recoff") ||
           ($2 == "rcvron") || ($2 == "rcvroff"))
  {
    # capture relevant parts of line
    chanId = $3
    fname = substr($2, 1, 3)
    if ($6 == "on")
      state = "On"
    else
      state = "Off"

    # +-----------------------------------------------------------------+
    # | rcvron/off control both the receiver and the amplifier blanking |
    # | recon/off only control the receiver; do receiver control first  |
    # +-----------------------------------------------------------------+

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
        dockAt = "end"
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d ee (rcvr)\n", id, idAt) >> logfile

    # NOW add the FIRST new SpinCAD element
    # -------------------------------------
    file = "'$library'/psgReceiver"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   %s\n", state) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++

    # +--------------------------------------------------+
    # | the following section is for rcvron/rcvroff only |
    # +--------------------------------------------------+
    if (fname == "rcv")
    {
      # decide which element to dock this one into
      if (was_delay == -1)
      {
        dockAt = "end"
        l_idAt = ff_pend_idAt
      }
      else
        l_idAt = ee_pend_idAt

      if (debug > 0)
        printf("%2d->%2d ee (blk)\n", id, idAt) >> logfile

      # NOW add the SECOND new SpinCAD element
      # --------------------------------------
      file = "'$library'/psgAmpBlank"
      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<state>")
        {
          getline < file
          printf("   %s\n", state) >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   %s\n", dock) >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   %s\n", dockAt) >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", chanId) >> tmpfile
        }
      }
      close(file)
      close(tmpfile)

      # decide which element to dock this one into
      if (was_delay == -1)
      {
        ff_pend_elems++
        ff_pend_idAt = id
      }
      else
      {
        ee_pend_elems++
        ee_pend_idAt = id
        # prepend new element to existing end-to-end docked sidechain
        system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
        system("mv '$ee_tmptarget0' '$ee_tmptarget'")
      }
      id++
    }
  }

  # +-------------------------------------------------------+
  # | obsblank / decblank / dec2blank / dec3blank / blankon |
  # |    (usually performed at end of preceding event)      |
  # +-------------------------------------------------------+
  else if (($2 == "obsblank")  || ($2 == "decblank")  ||
           ($2 == "dec2blank") || ($2 == "dec3blank") ||
           ($2 == "blankon"))
  {
    # capture relevant parts of line
    chanId = $3
    state="On"

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d ee (blkon)\n", id, idAt) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgAmpBlank"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   %s\n", state) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    # decide which element to dock this one into
    if (was_delay == -1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }

  # +-------------------------------------------+
  # | obsunblank / decunblank / dec2unblank /   |
  # | dec3unblank / blankoff                    |
  # |    (try performing inside adjacent delay) |
  # +-------------------------------------------+
  else if (($2 == "obsunblank")  || ($2 == "decunblank")  ||
           ($2 == "dec2unblank") || ($2 == "dec3unblank") ||
	   ($2 == "blankoff"))
  {
    # capture relevant parts of line
    chanId = $3
    state = "Off"

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d f%s (blkoff ch=%d)\n",
		id, l_idAt, substr(dockAt,1,1), chanId) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgAmpBlank"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   %s\n", state) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }


  # +---------------+
  # | ============= |
  # | AP BUS EVENTS |
  # | ============= |
  # +---------------+

  # +----------------------------------------------+
  # | rgradient                                    |
  # |    (always performed at start of next event) |
  # +----------------------------------------------+
  else if ($2 == "rgradient")
  {
    # capture relevant parts of line
    level = $7
    levelvalue=$8
    chanId = rfchans + 1

    # prepare addition of element into front-to-front docked sidechain
    tmpfile = "'$ff_tmptarget'"
    if (ff_pend_elems == 0)
    {
      if (debug > 0)
        printf("          Starting new \"ff\" chain\n") >> logfile
      ff_pend_Id = id
      ff_pend_idAt = id
      id++
      dockAt = "front"
    }
    else
    {
      dockAt = "end"
    }
    l_idAt = ff_pend_idAt

    if (debug > 0)
      printf("%2d->%2d f%s (rgrad)\n",
		id, l_idAt, substr(dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgGradient"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<value>")
      {
        getline < file
        printf("   %s\n", level)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   front\n") >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    ff_pend_elems++
    ff_pend_idAt = id
    id++
  }

  # +-------------------------------------------------------------------+
  # | obspower / decpower / dec2power / dec3power / dec4power / rlpower |
  # | observepower / decouplepower / power                              |
  # | i_power / i_pwrf (currently not supported by dps)                 |
  # |    (try performing inside adjacent delay)                         |
  # +-------------------------------------------------------------------+
  else if (($2 == "obspower") || ($2 == "decpower") ||
           ($2 == "dec2power") || ($2 == "dec3power") ||
	   ($2 == "dec4power") || ($2 == "rlpower") ||
	   ($2 == "observepower") || ($2 == "decouplepower") ||
	   ($2 == "power") || ($2 == "i_power"))
  {
    # capture relevant parts of line
    linenum = $1
    chanId = $3
    if (($2 == "power") || ($2 == "i_power"))
      value = "" checkphase($6, linenum, 1, 1)
    else
    {
      value = $6
      # remember power value and flag power change
      if (iflevel == 0)
      {
        powerval[chanId] = value
        setpower[chanId] = 1
      }
      else
      {
        powerval_c[chanId] = value
        setpower_if[chanId] = 1
        setpower_el[chanId] = 1
      }
    }

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
	if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }
    if (debug > 0)
      printf("%2d->%2d %s%s (power)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgAttn"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<value>")
      {
        getline < file
        printf("   %s\n", value) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }

  # +------------------------------------------------------+
  # | obspwrf / decpwrf / dec2pwrf / dec3pwrf / dec4pwrf / |
  # | rlpwrf / rlpwrm / ipwrf / ipwrm                      |
  # | i_pwrf (currently not supported by dps)              |
  # |    (try performing inside adjacent delay)            |
  # +------------------------------------------------------+
  else if (($2 == "obspwrf")  || ($2 == "decpwrf")  ||
           ($2 == "dec2pwrf") || ($2 == "dec3pwrf") ||
	   ($2 == "dec4pwrf") || ($2 == "xgate")    ||
	   ($2 == "rlpwrf")   || ($2 == "rlpwrm")   ||
	   ($2 == "pwrf")     || ($2 == "pwrm")     ||
           ($2 == "ipwrf")    || ($2 == "ipwrm")    ||
	   ($2 == "i_pwrf"))
  {
    # capture relevant parts of line
    linenum = $1
    fname = $2
    chanId = $3
    if (($2 == "pwrf") || ($2 == "pwrm") || ($2 == "i_pwrf"))
      value = "" checkphase($6, linenum, 1, 1)
    else
      value = $6

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
    {
      if (fname == "xgate")
        printf("%2d->%2d %s%s (xgate)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile
      else
        printf("%2d->%2d %s%s (pwrf)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile
    }

    # NOW add the new SpinCAD element
    # -------------------------------
    if (fname == "xgate")
      file = "'$library'/psgXgate"
    else
      file = "'$library'/psgFineAttn"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<value>")
      {
        getline < file
        printf("   %s\n", value) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }

  # +----------------------------------------------------------------+
  # | obsoffset / decoffset / dec2offset / dec3offset / dec4offset / |
  # | offset / ioffset                                               |
  # |    (try performing inside adjacent delay)                      |
  # +----------------------------------------------------------------+
  else if (($2 == "obsoffset") || ($2 == "decoffset") ||
           ($2 == "dec2offset") || ($2 == "dec3offset") ||
	   ($2 == "dec4offset") || ($2 == "offset") || ($2 == "ioffset"))
  {
    # capture relevant parts of line
    chanId = $3
    value = $6

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d %s%s (offset)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgOffset"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<value>")
      {
        getline < file
        printf("   %s\n", value) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }

  # +-------------------------------------------+
  # | obsprgon / decprgon / dec2prgon /         |
  # | dec3prgon / dec4prgon / prg_dec_on        |
  # |    (try performing inside adjacent delay) |
  # +-------------------------------------------+
  else if (($2 == "obsprgon") || ($2 == "decprgon") ||
           ($2 == "dec2prgon") || ($2 == "dec3prgon") ||
	   ($2 == "dec4prgon") || ($2 == "prg_dec_on"))
  {
    # capture relevant parts of line
    chanId = $3
    pattern = $6
    pw90 = $8
    dres = $10		# apparently unused in SpinCAD!

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
	if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }

    if (debug > 0)
      printf("%2d->%2d %s%s (prgon)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile

    # NOW add the FIRST of TWO new SpinCAD elements
    # ---------------------------------------------
    file = "'$library'/psgDecSelect"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<shapeName>")
      {
        getline < file
        if (substr(pattern,1,1) == "?")
          printf("   \"%s\"\n", substr(pattern,2,length(pattern)-1)) >> tmpfile
        else
          printf("   %s\n", pattern) >> tmpfile
      }
      else if ($1 == "<shapeWidth>")
      {
        getline < file
        printf("   %s\n", pw90) >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++

    # +--------------------------------------------------------------+
    # | The "obsprgon" family of functions must be emulated by TWO   |
    # | primitives in SpinCAD: the WFG setup (added above), followed |
    # | by the WFG gate control, added below.                        |
    # +--------------------------------------------------------------+

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      l_idAt = ff_pend_idAt
      dockAt = "end"
    }
    else
      l_idAt = ee_pend_idAt

    if (debug > 0)
      printf("%2d->%2d %s%s (prggate)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile

    # NOW add the SECOND of TWO new SpinCAD elements
    # ----------------------------------------------
    file = "'$library'/psgShapeGate"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   On\n") >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }

  # +-------------------------------------------+
  # | obsprgoff / decprgoff / dec2prgoff /      |
  # | dec3prgoff / dec4prgoff / prg_dec_off     |
  # |    (try performing inside adjacent delay) |
  # +-------------------------------------------+
  else if (($2 == "obsprgoff") || ($2 == "decprgoff") ||
           ($2 == "dec2prgoff") || ($2 == "dec3prgoff") ||
	   ($2 == "dec4prgoff") || ($2 == "prg_dec_off"))
  {
    # capture relevant parts of line
    chanId = $3

    # decide which element to dock this one into
    if (was_delay != 1)
    {
      # prepare addition of element into front-to-front docked sidechain
      tmpfile = "'$ff_tmptarget'"
      dock = "front"
      if (ff_pend_elems == 0)
      {
	if (debug > 0)
          printf("          Starting new \"ff\" chain\n") >> logfile
        ff_pend_Id = id
        ff_pend_idAt = id
        id++
        dockAt = "front"
      }
      else
      {
        dockAt = "end"
      }
      l_idAt = ff_pend_idAt
    }
    else
    {
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      dock = "end"
      if (ee_pend_elems == 0)
      {
        if (debug > 0)
          printf("          Starting new \"ee\" chain\n") >> logfile
        ee_pend_Id = id
        ee_pend_idAt = idAt
      }
      l_idAt = ee_pend_idAt
      dockAt = "end"
    }
    if (debug > 0)
      printf("%2d->%2d %s%s (prgoff)\n", id, l_idAt,
		substr(dock,1,1), substr(dockAt,1,1)) >> logfile

    # NOW add the new SpinCAD element
    # -------------------------------
    file = "'$library'/psgShapeGate"
    while ((getline < file) > 0)
    {
      print >> tmpfile
      if ($1 == "<id>")
      {
        getline < file
        printf("   %d\n", id) >> tmpfile
      }
      else if ($1 == "<state>")
      {
        getline < file
        printf("   Off\n") >> tmpfile
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   %s\n", dock) >> tmpfile
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", l_idAt) >> tmpfile
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        printf("   %s\n", dockAt) >> tmpfile
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        printf("   %d\n", chanId) >> tmpfile
      }
    }
    close(file)
    close(tmpfile)

    if (was_delay != 1)
    {
      ff_pend_elems++
      ff_pend_idAt = id
    }
    else
    {
      ee_pend_elems++
      ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
      system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
      system("mv '$ee_tmptarget0' '$ee_tmptarget'")
    }
    id++
  }


  # +--------+
  # | ====== |
  # | STATUS |
  # | ====== |
  # +--------+
  else if (($2 == "status") ||
           (($3 == 0) && ($2 == "statusdelay")))
  {
    statusIndex = $NF
    statusIndex++

    # +------------------------------------------------+
    # | switch decouplers off from previous status     |
    # |    (always performed at end of previous event) |
    # +------------------------------------------------+
    if (status > 0)
    {
      file = "'$library'/decoff"
      # prepare addition of element into end-to-end docked sidechain
      tmpfile = "'$ee_tmptarget0'"
      for (ch = 2; ch <= rfchans; ch++)
      {
        if (ee_pend_elems == 0)
        {
          if (debug > 0)
            printf("          Starting new \"ee\" chain\n") >> logfile
          ee_pend_Id = id
          ee_pend_idAt = idAt
        }
        l_idAt = ee_pend_idAt
        if (debug > 0)
          printf("%2d->%2d    (decoff chan=%d)\n", id, l_idAt, ch) >> logfile

        while ((getline < file) > 0)
        {
          print >> tmpfile
          if ($1 == "<id>")
          {
            getline < file
            printf("   %d\n", id) >> tmpfile
          }
          else if ($1 == "<idAt>")
          {
            getline < file
            printf("   %d\n", l_idAt) >> tmpfile
          }
          else if ($1 == "<chanId>")
          {
            getline < file
            printf("   %d\n", ch) >> tmpfile
          }
        }
        close(file)
        close(tmpfile)
        ee_pend_elems++
        ee_pend_idAt = id
      # prepend new element to existing end-to-end docked sidechain
        system("cat '$ee_tmptarget' >> '$ee_tmptarget0' 2>/dev/null")
        system("mv '$ee_tmptarget0' '$ee_tmptarget'")
        id++
      }
    }

    # +----------------------------------------------+
    # | switch decouplers for new status field       |
    # |    (always performed at start of next event) |
    # +----------------------------------------------+

    # prepare addition of element into front-to-front docked sidechain
    tmpfile = "'$ff_tmptarget'"
    if (ff_pend_elems == 0)
    {
      if (debug > 0)
        printf("          Starting new \"ff\" chain\n") >> logfile
      ff_pend_Id = id
      ff_pend_idAt = id
      id++
      dockAt = "front"
    }
    else
    {
      dockAt = "end"
    }
    l_idAt = ff_pend_idAt

    file = "'$library'/decouple"
    for (ch = 2; ch <= rfchans; ch++)
    {
      if (debug > 0)
        printf("%2d->%2d f%s (decouple ch=%d)\n",
		id, l_idAt, substr(dockAt,1,1), ch) >> logfile

      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<attr1>")
        {
          getline < file
          if (ch > 2)
            printf("   1/dmf%d\n", ch - 1) >> tmpfile
          else
            printf("   1/dmf\n") >> tmpfile
        }
        else if ($1 == "<attr2>")
        {
          getline < file
          if (ch > 2)
            printf("   dm%d\n", ch - 1) >> tmpfile
          else
            printf("   dm\n") >> tmpfile
        }
        else if ($1 == "<attr3>")
        {
          getline < file
          printf("   %d\n", statusIndex) >> tmpfile
        }
        else if (($1 == "<attr4>") && (statusIndex > 2))
        {
          if ((iflevel == 0) && (setpower[ch] == 1))
          {
            getline < file
            printf("   %s\n", powerval[ch]) >> tmpfile
            setpower[ch] = 0
          }
          else if ((iflevel > 0) && (setpower_if[ch] == 1))
          {
            getline < file
            printf("   %s\n", powerval_c[ch]) >> tmpfile
            setpower_if[ch] = 0
          }
          else if ((iflevel > 0) && (setpower_el[ch] == 1))
          {
            getline < file
            printf("   %s\n", powerval_c[ch]) >> tmpfile
            setpower_el[ch] = 0
          }
          else
          {   
            getline < file
            printf("   Unaltered\n") >> tmpfile
          }
        }
        else if ($1 == "<attr5>")
        {
          getline < file
          printf("   Unaltered\n") >> tmpfile
        }
        else if ($1 == "<attr6>")
        {
          getline < file
          if (ch > 2)
            printf("   dmm%d\n", ch - 1) >> tmpfile
          else
            printf("   dmm\n") >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   %s\n", dockAt) >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", ch) >> tmpfile
        }
      }
      close(file)
      close(tmpfile)
      ff_pend_elems++
      ff_pend_idAt = id
      id++
    }
    status = 1
  }


  # +-----------+
  # | setstatus |
  # +-----------+
  else if ($2 == "setstatus")
  {
    # capture relevant parts of line
    chanId = $3
    dmm = $6
    gate_on = $8
    synch = $10		# currently unused
    dmf = $12

    # prepare addition of element into front-to-front docked sidechain
    tmpfile = "'$ff_tmptarget'"
    if (ff_pend_elems == 0)
    {
      if (debug > 0)
        printf("          Starting new \"ff\" chain\n") >> logfile
      ff_pend_Id = id
      ff_pend_idAt = id
      id++
      dockAt = "front"
    }
    else
    {
      dockAt = "end"
    }
    l_idAt = ff_pend_idAt

    if (debug > 0)
      printf("          (setstatus ch=%d)\n", chanId) >> logfile

    # +-----------------------------------------------------------------+
    # | If the gate is "TRUE", we use standard "decoupler on" composite |
    # +-----------------------------------------------------------------+
    if (gate_on == "TRUE")
    {
      if (debug > 0)
        printf("%2d->%2d f%s (decouple ch=%d)\n",
		id, l_idAt, substr(dockAt,1,1), chanId) >> logfile

      file = "'$library'/decouple"
      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<attr1>")
        {
          getline < file
          printf("   1/%s\n", dmf) >> tmpfile
        }
        else if ($1 == "<attr2>")
        {
          if ((iflevel == 0) && (setpower[chanId] == 1))
          {
            getline < file
	    printf("   %s\n", powerval[chanId]) >> tmpfile
	    setpower[chanId] = 0
          }
          else if ((iflevel > 0) && (setpower_if[chanId] == 1))
          {
            getline < file
	    printf("   %s\n", powerval_c[chanId]) >> tmpfile
	    setpower_if[chanId] = 0
          }
          else if ((iflevel > 0) && (setpower_el[chanId] == 1))
          {
            getline < file
	    printf("   %s\n", powerval_c[chanId]) >> tmpfile
	    setpower_el[chanId] = 0
          }
	  else
          {
            getline < file
            printf("   Unaltered\n") >> tmpfile
          }
        }
        else if ($1 == "<attr3>")
        {
          getline < file
          if (substr(dmm,1,1) == "?")
            printf("   \"%s\"\n", substr(dmm,2,length(dmm))) >> tmpfile
          else
            printf("   %s\n",dmm) >> tmpfile
        }
        else if ($1 == "<attr4>")
        {
          getline < file
          printf("   \"y\"\n") >> tmpfile
        }
        else if ($1 == "<attr5>")
        {
          getline < file
          printf("   1\n") >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   %s\n", dockAt) >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", chanId) >> tmpfile
        }
      }
      close(file)
      close(tmpfile)
      ff_pend_elems++
      ff_pend_idAt = id
      id++
    }

    # +-------------------------------------------------------------------+
    # | If the gate is "FALSE", switch rf gate to Off and set dmm and dmf |
    # +-------------------------------------------------------------------+
    else
    {
      # +------------------+
      # | r.f. gate -> Off |
      # +------------------+
      if (debug > 0)
        printf("%2d->%2d f%s (rf_off ch=%d)\n",
		id, l_idAt, substr(dockAt,1,1), chanId) >> logfile

      file = "'$library'/psgXmtr"
      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<state>")
        {
          getline < file
          printf("   Off\n") >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   %s\n", dockAt) >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", chanId) >> tmpfile
        }
      }
      close(file)
      ff_pend_elems++
      l_idAt = id
      id++

      # +---------------------+
      # | set modulation mode |
      # +---------------------+
      if (debug > 0)
        printf("%2d->%2d fe (setdmm ch=%d)\n", id, l_idAt, chanId) >> logfile

      file = "'$library'/psgDecMode"
      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<decMode>")
        {
          getline < file
          if (substr(dmm,1,1) == "?")
            printf("   \"%s\"\n", substr(dmm,2,length(dmm))) >> tmpfile
          else
            printf("   %s\n",dmm) >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   end\n") >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", chanId) >> tmpfile
        }
      }
      close(file)
      ff_pend_elems++
      l_idAt = id
      id++

      # +--------------------------+
      # | set modulation frequency |
      # +--------------------------+
      if (debug > 0)
        printf("%2d->%2d fe (setdmf ch=%d)\n", id, l_idAt, chanId) >> logfile

      file = "'$library'/psgDecFrq"
      while ((getline < file) > 0)
      {
        print >> tmpfile
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id) >> tmpfile
        }
        else if ($1 == "<decFrq>")
        {
          getline < file
          printf("   %s\n", dmf) >> tmpfile
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n") >> tmpfile
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          printf("   %d\n", l_idAt) >> tmpfile
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   end\n") >> tmpfile
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   %d\n", chanId) >> tmpfile
        }
      }
      close(file)
      close(tmpfile)
      ff_pend_elems++
      ff_pend_idAt = id
      id++
    }
  }
}


# +-------------------------------------------------------+
# | ===================================================== |
# | TRAILER: implicit acquisition, switch off decouplers, |
# |          add phase tables / receiver phase setting    |
# | ===================================================== |
# +-------------------------------------------------------+
END {

  # +---------------------------------------+
  # | make acquisition explicit for SpinCAD |
  # +---------------------------------------+
  if (acquire == 0)
  {
    if (ee_pend_elems > 0)
    {
      tmpId = id
      id = ee_pend_Id
      add_ee_pending()
      ee_pend_elems = 0
      id = tmpId
    }

    if (ff_pend_elems > 0)
    {
      tmpId = id
      lid = ff_pend_Id
    }
    else
      lid = id

    # +------------------------------------------+
    # | define table for oph, if still necessary |
    # +------------------------------------------+
    if (phoph == 0)
    {
      # assume that the observe phase is stored in the dps phase table output
      # (dpstable) with a (dpsdata) line number of 0
      if (ophmod == 0)
        ophn = definephase("oph", 0, 1, 90)
      else
        ophn = definephase("new", 0, 1, 90)
    }

    if (debug > 0)
      printf("%2d->%2d fe (acquire)\n", lid, idAt) >> logfile

    file = "'$library'/acquire"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
	printf("   %d\n", lid)
      }
      else if ($1 == "<attr1>")
      {
        getline < file
        if (substr(ophn,1,2) == "ph")
	{
          printf("   \"%s\"\n", ophn) 	# use one of these 2 lines
        # printf("   %s\n", ophn)      	# (this should be enough)
        }
        else
          printf("   \"%s\"\n", ophn)
      }
      else if ($1 == "<attr2>")
      {
        getline < file
	printf("   None\n")
      }
      else if ($1 == "<dock>")
      {
        getline < file
	printf("   front\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
	if (idAt > 0)
	  printf("   %d\n", idAt)
	else
	  printf("   start\n")
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
	printf("   end\n")
      }
      else if ($1 == "<chanId>")
      {
        getline < file
	printf("   1\n")
      }
    }
    close(file)
    idAt = lid

    if (ff_pend_elems == 0)
      id++
    else
    {
      add_ff_pending("front")
      ff_pend_elems = 0
      id = tmpId
    }
  }

  # +------------------------------------------------------+
  # | switch decouplers off at end of explicit acquisition |
  # +------------------------------------------------------+
  if (status > 0)
  {
    file = "'$library'/decoff"
    for (ch = 2; ch <= rfchans; ch++)
    {
      if (debug > 0)
        printf("%2d->%2d ee (decoff chan=%d)\n", id, idAt, ch) >> logfile

      while ((getline < file) > 0)
      {
        print
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", id)
        }
        else if ($1 == "<dock>")
        {
          getline < file
	  printf("   end\n")
        }
        else if ($1 == "<idAt>")
        {
          getline < file
	  if (idAt > 0)
	    printf("   %d\n", idAt)
	  else
	    printf("   start\n")
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
	  printf("   end\n")
        }
        else if ($1 == "<chanId>")
        {
          getline < file
	  printf("   %d\n", ch)
        }
      }
      close(file)
      id++
    }
  }

  # +------------------------------------------+
  # | define table for oph, if still necessary |
  # +------------------------------------------+
# if (phoph == 0)
# {
#   # assume that the observe phase is stored in the dps phase table output
#   # (dpstable) with a (dpsdata) line number of 0
#   if (ophmod == 0)
#     ophn = definephase("oph", 0, 1, 90)
#   else
#     ophn = definephase("new", 0, 1, 90)
# }

  # +---------------------------+
  # | add table objects to code |
  # +---------------------------+
  ixph=0
  phsfile = "'$phstarget'"
  while ((getline < phsfile) > 0)
  {
    print
    if ($1 == "<id>")
    {
      getline < phsfile
      printf("   %d\n", id)
      id ++
    }
    else if ($1 == "<idAt>")
    {
      getline < phsfile
      if (ixph > 0)
        printf("   %d\n", id - 2)
      else
	printf("   phase\n")
      ixph++
    }
  }
  close(phsfile)
  system("rm -f '$phstarget'")

  # +------------------------+
  # | receiver phase setting |
  # +------------------------+
# file = "'$library'/recphase"
# while ((getline < file) > 0)
# {
#   print
#   if ($1 == "<attr1>")
#   {
#     getline < file
#     if (substr(ophn,1,2) == "ph")
#     {
#       printf("   \"%s\"\n", ophn)	# use one of these 2 lines
#     # printf("   %s\n", ophn		# (this should be enough)
#     }
#     else
#       printf("   \"%s\"\n", ophn)
#   }
#   else if ($1 == "<id>")
#   {
#     getline < file
#     printf("   %d\n", id)
#   }
#   else if ($1 == "<dock>")
#   {
#     getline < file
#     printf("   front\n")
#   }
#   else if ($1 == "<idAt>")
#   {
#     getline < file
#     printf("   %d\n", id - 1)
#   }
#   else if ($1 == "<dockAt>")
#   {
#     getline < file
#     printf("   end\n")
#   }
#   else if ($1 == "<chanId>")
#   {
#     getline < file
#     printf("   0\n")
#   }
#   else if ($1 == "<x>")
#   {
#     getline < file
#     printf("   %d\n", 100 + phasecount*15)
#   }
# }
# close(file)

  # +-------------------------------------------+
  # | add pulse sequence trailer (comment etc.) |
  # +-------------------------------------------+
  file = "'$library'/trailer"
  while ((getline < file) > 0)
  {
    print
    if ($1 == "<date>")
    {
      getline < file
      "date" | getline
      printf("   %s\n",$0)
    }
    else if ($1 == "<comment>")
    {
      getline < file
      printf("\"'$seqname'\" SpinCAD Pulse Sequence\n")
      printf("   Generated from VNMR sequence \"'$Cseq'.c\"\n")
      printf("   by \"$cmdname\" version '$version_ID' '$version_date'\n\n")
      printf("DISCLAIMER: Sequences converted using \"$cmdname\" may\n")
      printf("            be partially dysfunctional or incomplete\n")
      printf("            and need to be checked before being used!\n")
    }
  }

  # +--------------------------------------------------+
  # | finish pulse sequence file with closing XML line |
  # +--------------------------------------------------+
  if (debug > 0)
    printf("Finishing sequence with XML closing line\n") >> logfile
  printf("</spincadSequence>\n")
  close(file)
}


# +----------------------+
# | ==================== |
# | FUNCTION DEFINITIONS |
# | ==================== |
# +----------------------+


# +----------------------------------------+
# | add an r.f. pulse on specified channel |
# +----------------------------------------+
function addPulse(l_id, len, predly, ph, pwr, ch,
		  dk, l_idAt, dkAt, tbllin, tblnum) {
  if (debug > 0)
    printf("%2d->%2d %s%s (pulse)\n", l_id, l_idAt,
		substr(dk,1,1), substr(dkAt,1,1)) >> logfile

  phasename = "" checkphase(ph, tbllin, tblnum, 90)
  dlen = 10	# (standard display width is 10)

  file = "'$library'/pulse"
  while ((getline < file) > 0)
  {
    print
    if ($1 == "<id>")
    {
      getline < file
      printf("   %d\n", l_id)
    }
    else if ($1 == "<attr1>")
    {
      getline < file
      printf("   %s\n", len)
    }
    else if ($1 == "<attr2>")
    {
      getline < file
      printf("   %s\n", predly)
    }
    else if ($1 == "<attr3>")
    {
      getline < file
      if (substr(phasename,1,2) == "ph")
      {
        printf("   \"%s\"", phasename)		# use one of these 2 lines
      # printf("   %s", phasename)		# (this should be enough)
      }
      else
        printf("   \"%s\"", phasename)
      if (chsaps[ch] == "")
	printf("\n")
      else
	printf(" + \"%s\"\n", chsaps[ch])
    }
    else if ($1 == "<attr7>")
    {
      getline < file
      printf("   %s\n", pwr)
    }
    else if ($1 == "<dock>")
    {
      getline < file
      printf("   %s\n", dk)
    }
    else if ($1 == "<idAt>")
    {
      getline < file
      if (l_idAt > 0)
        printf("   %d\n", l_idAt)
      else
        printf("   start\n")
    }
    else if ($1 == "<dockAt>")
    {
      getline < file
      printf("   %s\n", dkAt)
    }
    else if ($1 == "<chanId>")
    {
      getline < file
      printf("   %d\n", ch)
    }
    else if ($1 == "<len>")
    {
      getline < file
      # scale displayed pulse width with obvious/common multipliers;
      # we do not quite scale the pulses proportionally
      if      ((len ~ /4\*/) || (len ~ /\*4/) || (len ~ /360/))
        printf("   %d\n", 3.0*dlen)
      else if ((len ~ /3\*/) || (len ~ /\*3/) || (len ~ /270/))
        printf("   %d\n", 2.4*dlen)
      else if ((len ~ /2\*/) || (len ~ /\*2/) || (len ~ /180/))
        printf("   %d\n", 1.8*dlen)
      else if ((len ~ /1\.5\*/) || (len ~ /\*1\.5/) || (len ~ /135/))
        printf("   %d\n", 1.4*dlen)
      else if ((len ~ /0\.5\*/) || (len ~ /\*0\.5/) ||
	       (len ~ /\/2/) || (len ~ /45/))
        printf("   %d\n", 0.6*dlen)
      else
        printf("   %d\n", dlen)
    }
  }
  close(file)
}


# +----------------------------------------------+
# | add a shaped r.f. pulse on specified channel |
# +----------------------------------------------+
function addShapedPulse(l_id, shp, len, predly, ph, pwr, ch,
		        dk, l_idAt, dkAt, tbllin, tblnum) {
  if (debug > 0)
    printf("%2d->%2d fe (shaped_pulse)\n", l_id, idAt,
                substr(dk,1,1), substr(dkAt,1,1)) >> logfile

  phasename = "" checkphase(ph, tbllin, tblnum, 90)
  dlen = 10	# standard display width

  file = "'$library'/shapedpulse"
  while ((getline < file) > 0)
  {
    print
    if ($1 == "<id>")
    {
      getline < file
      printf("   %d\n", l_id)
    }
    else if ($1 == "<attr1>")
    {
      getline < file
      if (substr(shp,1,1) == "?")
        printf("   \"%s\"\n", substr(shp, 2, 128))
      else
        printf("   %s\n", shp)
    }
    else if ($1 == "<attr2>")
    {
      getline < file
      printf("   %s\n", len)
    }
    else if ($1 == "<attr3>")
    {
      getline < file
      printf("   %s\n", predly)
    }
    else if ($1 == "<attr4>")
    {
      getline < file
      if (substr(phasename,1,2) == "ph")
      {
        printf("   \"%s\"", phasename)		# use one of these 2 lines
      # printf("   %s", phasename)		# (this should be enough)
      }
      else
        printf("   \"%s\"", phasename)
      if (chsaps[ch] == "")
	printf("\n")
      else
	printf(" + \"%s\"\n", chsaps[ch])
    }
    else if ($1 == "<attr8>")
    {
      getline < file
      printf("   %s\n", pwr)
    }
    else if ($1 == "<dock>")
    {
      getline < file
      printf("   %s\n", dk)
    }
    else if ($1 == "<idAt>")
    {
      getline < file
      if (l_idAt > 0)
        printf("   %d\n", l_idAt)
      else
        printf("   start\n")
    }
    else if ($1 == "<dockAt>")
    {
      getline < file
      printf("   %s\n", dkAt)
    }
    else if ($1 == "<chanId>")
    {
      getline < file
      printf("   %d\n", ch)
    }
    else if ($1 == "<len>")
    {
      getline < file
      # scale displayed pulse width with obvious/common multipliers
      if      ((len ~ /4\*/) || (len ~ /\*4/) || (len ~ /360/))
        printf("   %d\n", 3*dlen)
      else if ((len ~ /3\*/) || (len ~ /\*3/) || (len ~ /270/))
        printf("   %d\n", 3*dlen)
      else if ((len ~ /2\*/) || (len ~ /\*2/) || (len ~ /180/))
        printf("   %d\n", 2*dlen)
      else if ((len ~ /1\.5\*/) || (len ~ /\*1\.5/) || (len ~ /135/))
        printf("   %d\n", 1.5*dlen)
      else if ((len ~ /0\.5\*/) || (len ~ /\*0\.5/) ||
	       (len ~ /\/2/) || (len ~ /45/))
        printf("   %d\n", 0.6*dlen)
      else
        printf("   %d\n", dlen)
    }
  }
  close(file)
}


# +------------------------------------------------------------------+
# | add "front-to-front" pending stuff, i.e., elements that were     |
# | defined prior to the element they are docked into front-to-front |
# +------------------------------------------------------------------+
function add_ff_pending(l_dockAt) {
  if (ff_pend_elems > 0)
  {
    if (l_dockAt == "end")
    {
      if (debug > 0)
      {
        printf("%s\n",
	   "Emergency docking of pending front-to-front elements:") >> logfile
        printf("%s\n",
           "     need to insert extra delay for docking elements!") >> logfile
      }
  
      # remember the current ID
      #    if there are defined elements docked front-to-front to this one
      lid = ff_pend_Id
  
      if (debug > 0)
        printf("%2d->%2d fe (delay)\n", lid, idAt) >> logfile
  
      # NOW add the new SpinCAD element
      # -------------------------------
      file = "'$library'/delay"
      while ((getline < file) > 0)
      {
        print
        if ($1 == "<id>")
        {
          getline < file
          printf("   %d\n", lid)
        }
        else if ($1 == "<attr1>")
        {
          getline < file
          printf("   0.0\n")
        }
        else if ($1 == "<dock>")
        {
          getline < file
          printf("   front\n")
        }
        else if ($1 == "<idAt>")
        {
          getline < file
          if (idAt > 0)
            printf("   %d\n", idAt)
          else
            printf("   start\n")
        }
        else if ($1 == "<dockAt>")
        {
          getline < file
          printf("   end\n")
        }
        else if ($1 == "<chanId>")
        {
          getline < file
          printf("   1\n")
        }
        else if ($1 == "<len>")
        {
          getline < file
          printf("   15\n")
        }
      }
      close(file)
      c_dockAt = "end"
      idAt = lid
    }

    first = 1
    id = 0
    lastId = 0
    file = "'$ff_tmptarget'"
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
        id = $1
        print
      }
      else if ($1 == "<dock>")
      {
        getline < file
	if (first == 1)
          printf("   front\n")
        else
          print
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        print
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
 	# first element docked front-to-front, others front-to-end
	if (first == 1)
          printf("   front\n")
        else
          print
      }
      else if (substr($0,1,2) == "</")
        first = 0
    }
    close(file)
    system("rm -f '$ff_tmptarget'")
    if (l_dockAt == "end")
    {
      idAt = lid
      id++
    }
  }
}


# +----------------------------------------------------------------+
# | add "end-to-end" pending stuff, i.e., a chain of elements that |
# | are to be docked end-to-end into a defined/existing element    |
# |   The complication with this is that the elements are defined  |
# |   from left to right (to keep the order), but must be docked   |
# |   from right to left, i.e., the elements must be renumbered.   |
# +----------------------------------------------------------------+
function add_ee_pending() {
  if (ee_pend_elems > 0)
  {
    curId = 0
    prev_elem = 0
    file = "'$ee_tmptarget'"

    # first scan the file to establish a list of element IDs
    first = 1
    while ((getline < file) > 0)
    {
      if ($1 == "<idAt>")
      {
	getline < file
        prev_elem = $1
      }
    }
    close(file)

    # now append the element chain and correct id, dock, idAt, dockAt
    first = 1
    while ((getline < file) > 0)
    {
      print
      if ($1 == "<id>")
      {
        getline < file
	curId = $1
        printf("   %d\n", curId)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        printf("   end\n")
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        printf("   %d\n", prev_elem)
        prev_elem = curId
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
	# last element docked end-to-end, others end-to-front
        if (first == 1)
        {
          printf("   end\n")
	  first = 0
        }
        else
          printf("   front\n")
      }
    }
    close(file)
    system("rm -f '$ee_tmptarget' '$ee_tmptarget0'")
  }
}


# +--------------------------------------------------+
# | mark phases that are calculated by real-time     |
# |   math in C: next time when this phase variable  |
# |   is used, it will be treated as new phase table |
# +--------------------------------------------------+
function resetphase(ph) {
  if (ph == "oph")
    phoph = 0
  else if ((substr(ph,1,1) == "v") &&
           (substr(ph,2,2) > 0) && (substr(ph,2,2) < 15))
  {
    phn = substr(ph,2,2)
    phv[phn] = 0
  }
  # try recognizing substituted phase variables
  else
  {
    i = phxcount
    while ((i > 0) && (phxs[i] != ph))
      i--
    if ((i > 0) && (phxs[i] == ph))
      phx[i] = 0
  }
}


# +---------------------------------------------+
# | check phase variables, set up SpinCAD phase |
# |   table in temporary file, mark phase as    |
# |   used, return SpinCAD phase table name     |
# +---------------------------------------------+
function checkphase(ph, tbllin, tblnum, multiplier) {
  if (debug > 0)
    printf("          checkphase %-6s (line %d/%d, mult=%f)\n", ph,
                	tbllin, tblnum, multiplier) >> logfile

  if (ph == "ct")
  {
#   return ("ctss")
    return ("ct")
  }
  else if ((ph == "bsctr") || (ph == "bsval") ||
	   (ph == "ssctr") || (ph == "ssval"))
  {
    return (ph)
  }
  else if (ph == "id2")
  {
    return ("it1")
  }
  else if (ph == "id3")
  {
    return ("it2")
  }
  else if (ph == "id4")
  {
    return ("it3")
  }
  else if (ph == "zero")
  {
    if (ph0 == 0)
      name = definephase(ph, 0, 0, multiplier)
    ph0 = 1
    return ("0")
  }
  else if (ph == "one")
  {
    if (ph90 == 0)
      name = definephase(ph, 0, 0, multiplier)
    ph90 = 1
    return ("90")
  }
  else if (ph == "two")
  {
    if (ph180 == 0)
      name = definephase(ph, 0, 0, multiplier)
    ph180 = 1
    return ("180")
  }
  else if (ph == "three")
  {
    if (ph270 == 0)
      name = definephase(ph, 0, 0, multiplier)
    ph270 = 1
    return ("270")
  }
  else if (ph == "oph")
  {
    if (phoph == 0)
    {
      if (ophmod == 0)
	ophn = definephase("oph", tbllin, tblnum, multiplier)
      else
	ophn = definephase("new", tbllin, tblnum, multiplier)
    }
    phoph = 1
    return(ophn)
  }
  # now check for "v" real-time variables
  else if ((substr(ph,1,1) == "v") &&
	   (substr(ph,2,2) > 0) && (substr(ph,2,2) < 15))
  {
    phn = substr(ph,2,2)
    if (phv[phn] == 0)
      phvn[phn] = definephase("new", tbllin, tblnum, multiplier)
    phv[phn] = 1
    return(phvn[phn])
  }
  # now check for table names t1 .. t60
  else if ((substr(ph,1,1) == "t") &&
	   (substr(ph,2,2) > 0) && (substr(ph,2,2) < 61))
  {
    phn = substr(ph,2,2)
    if (pht[phn] == 0)
      phtn[phn] = definephase("new", tbllin, tblnum, multiplier)
    pht[phn] = 1
    return(phtn[phn])
  }
  # we can accommodate up to (lastphx) [64] substituted phase variables
  else
  {
    i = phxcount
    while ((i > 0) && (phxs[i] != ph))
      i--
    if ((i > 0) && (phxs[i] == ph))
    {
      if (phx[i] == 0)
      {
        phxn[i] = definephase("new", tbllin, tblnum, multiplier)
      }
      phx[i] = 1
      return(phxn[i])
    }
    else
    {
      if (phxcount < lastphx)
      {
        phxcount++
        phxs[phxcount] = ph
        phxn[phxcount] = definephase("new", tbllin, tblnum, multiplier)
        phx[phxcount] = 1
        return(phxn[phxcount])
      }
    }
  }
  return ph
}


# +-------------------------------+
# | define a SpinCAD phase table, |
# |   store in temporary file     |
# +-------------------------------+
function definephase(ph, tbllin, tblnum, multiplier) {
  if (debug > 0)
    printf("          definephase %-5s (line %d/%d, mult=%f)\n", ph,
                	tbllin, tblnum, multiplier) >> logfile

  file = "'$library'/phase"
  phsfile = "'$phstarget'"
  phasecount++
  if (ph == "zero")
    name="0"
  else if ((ph == "one") && (multiplier == 90))
    name="90"
  else if ((ph == "two") && (multiplier == 90))
    name="180"
  else if ((ph == "three") && (multiplier == 90))
    name="270"
  else
  {
    scph++
    name="ph" scph
  }

  while ((getline < file) > 0)
  {
    print >> phsfile
    if ($1 == "<attr1>")
    {
      getline < file
      printf("   %s\n", name) >> phsfile
    }
    if ($1 == "<attr2>")
    {
      getline < file
      if (ph == "zero")
        printf("   0.0\n") >> phsfile
      else if (ph == "one")
        printf("   %3.1f\n", multiplier) >> phsfile
      else if (ph == "two")
        printf("   %3.1f\n", 2*multiplier) >> phsfile
      else if (ph == "three")
        printf("   %3.1f\n", 3*multiplier) >> phsfile
      else if ((ph == "oph") || (ph == "ct"))
      {
        printf("   0.0") >> phsfile
	for (phs = multiplier; phs < 359.99; phs += multiplier)
	  printf(" %3.1f",phs) >> phsfile
	printf("\n") >> phsfile
      }
      else
      {
        if ((dotables == 1) && (tblnum > 0))
        {
	  # extract relevant line from phase table file, by
	  # matching dpsdata line number and table number
	  gotphase = 0
 	  do
          {
	    res = getline < tblfile
            if ((res > 0) && ($1 == tbllin) && ($2 == tblnum))
              gotphase = 1
          }
          while ((gotphase == 0) && (res > 0))
          close(tblfile)

	  # if table extraction successful, add table to definition
	  # otherwise use default table definition "0.0"
          if (gotphase == 0)
            printf("   0.0") >> phsfile
          else
          {
            if (debug > 0)
	    {
	      printf("             matching line from table file:\n") >> logfile
	      printf("             %s\n", $0) >> logfile
	    }

	    # print up to 8 tokens per line, but not more than ca. 64 chars
            printf("   ") >> phsfile
            linelen = 2
	    tokens = 0
            for (field = 3; field <= NF; field++)
            {
	      # check for shorthand repeater token
              if (substr($field,1,1) == "^")
              {
                linelen += length($field)
                printf("%s", $field) >> phsfile
              }
              else
              {
		# new table value; start new line, if necessary
		if ((tokens >= 8) || (linelen > 60))
		{
		  printf("\n") >> phsfile
		  linelen = 2
		  tokens = 0
		}

		# calculate table value, using multiplier argument
                tblval = multiplier * $field

		# this should be done already - just to be sure ...
		if (multiplier == 90)
		  tblval %= 360

		# re-calculate line length
                if (tblval > 99)
                  linelen += 4
                else if (tblval > 9)
                  linelen += 3
                else
                  linelen += 2
 		if (tblval < 0)
		  linelen++
		
		# ensure proper spacing of table values
	  	if (tokens > 0)
		  printf(" ") >> phsfile

		# print integers if possible, otherwise use
		# one digit after the decimal point
		frac = tblval % 1
		if (frac < 0.0)
		  frac *= -1.0
		if (frac > 0.05)
		{
		  linelen += 2
                  printf("%3.1f", tblval) >> phsfile
		}
		else
                  printf("%1.0f", tblval) >> phsfile
		tokens++
              }
            }
          }
          printf("\n") >> phsfile
        }
        else
          printf("   0.0\n") >> phsfile
      }
    }
    else if ($1 == "<attr3>")
    {
      getline < file
      printf("   ctss\n") >> phsfile
    }
    else if ($1 == "<dock>")
    {
      getline < file
      printf("   front\n") >> phsfile
    }
    else if ($1 == "<dockAt>")
    {
      getline < file
      printf("   end\n") >> phsfile
    }
    else if ($1 == "<chanId>")
    {
      getline < file
      printf("   0\n") >> phsfile
    }
    else if ($1 == "<x>")
    {
      getline < file
      printf("   %d\n", 100 + (phasecount - 1)*15) >> phsfile
    }
  }
  close(file)
  close(phsfile)
  return(name)
}
' > "$target"

if [ $debug -gt 0 ]; then
  echo ""
  cat $logfile
  echo ""
fi


# +--------------------------------------------------------+
# | Now, rearrange element IDs for proper numeric sequence |
# +--------------------------------------------------------+
echo $target | nawk '
{
  file = $0
  tmpfile = $0 ".tmp"
}
END {
  debug = '$debug'
  id = 0
  new = 0
  idAt = ""
  idAtnum = 0
  dock = ""
  dockAt = ""
  label = ""
  chanId = 0
  ix = 0
  i = 0
  j = 0

  # +--------------------------------------------+
  # | first, extract the sequence of element-IDs |
  # +--------------------------------------------+
  # debugging: print list of numbered elements
  if (debug > 0)
  {
    printf("Element list BEFORE renumbering:\n")
    while ((getline < file) > 0)
    {
      if (($0 == "<channel>") || ($0 == "<pulseSequence>"))
        id = 0
      else if ((substr($0,1,1) == "<") && (substr($0,1,2) != "</"))
      {
        label = substr($0,2,length($0)-2)
      }
      else if (($1 == "<value>") || ($1 == "<state>") || ($1 == "<attr1>"))
      {
        getline < file
        label = label " " $1
      }
      else if ($1 == "<id>")
      {
        getline < file
        id = $1
	ix++
        idList[ix] = id
      }
      else if ($1 == "<idAt>")
      {
        getline < file
        idAt = substr($1,1,3)
      }
      else if ($1 == "<dock>")
      {
        getline < file
        dock = substr($1,1,1)
      }
      else if ($1 == "<dockAt>")
      {
        getline < file
        dockAt = substr($1,1,1)
      }
      else if ($1 == "<chanId>")
      {
        getline < file
        chanId = substr($1,1,1)
      }
#     else if ($1 == "<label>")
#     {
#       getline < file
#       label = $0
#     }
      else if ((substr($0,1,2) == "</") && (id > 0))
      {
        printf("%3s ->%3s   %s%s  %d  %s\n",
		id, idAt, dock, dockAt, chanId, label)
      }
    }
    close(file)
    printf("\n\n")
  }
  else
  {
    while ((getline < file) > 0)
    {
      if (($0 == "<channel>") || ($0 == "<pulseSequence>"))
        id = 0
      else if ($1 == "<id>")
      {
        getline < file
        id = $1
        ix++
        idList[ix] = id
      }
    }
    close(file)
  }

  # +------------------------------------------+
  # | new, reshuffle IDs and write new version |
  # +------------------------------------------+
  while ((getline < file) > 0)
  {
    print >> tmpfile
    if ($1 == "<id>")
    {
      getline < file
      new = newId($1)
      if (new == 0)
	terminate()
      printf("   %d\n", new) >> tmpfile
    }
    else if ($1 == "<idAt>")
    {
      getline < file
      if (($1 == "start") || ($1 == "phase"))
	print >> tmpfile
      else
      {
        new = newId($1)
        if (new == 0)
	  terminate()
        printf("   %d\n", new) >> tmpfile
      }
    }
  }
  close(tmpfile)

  # debugging: print out revised list of numbered elements
  if (debug > 0)
  {
    printf("Element list AFTER renumbering:\n")
    while ((getline < tmpfile) > 0)
    {
      if (($0 == "<channel>") || ($0 == "<pulseSequence>"))
        id = 0
      else if ((substr($0,1,1) == "<") && (substr($0,1,2) != "</"))
      {
        label = substr($0,2,length($0)-2)
      }
      else if (($1 == "<value>") || ($1 == "<state>") || ($1 == "<attr1>"))
      {
        getline < tmpfile
        label = label " " $1
      }
      else if ($1 == "<id>")
      {
        getline < tmpfile
        id = $1
	ix++
        idList[ix] = id
      }
      else if ($1 == "<idAt>")
      {
        getline < tmpfile
        idAt = substr($1,1,3)
      }
      else if ($1 == "<dock>")
      {
        getline < tmpfile
        dock = substr($1,1,1)
      }
      else if ($1 == "<dockAt>")
      {
        getline < tmpfile
        dockAt = substr($1,1,1)
      }
      else if ($1 == "<chanId>")
      {
        getline < tmpfile
        chanId = substr($1,1,1)
      }
#     else if ($1 == "<label>")
#     {
#       getline < tmpfile
#       label = $0
#     }
      else if ((substr($0,1,2) == "</") && (id > 0))
      {
        printf("%3s ->%3s   %s%s  %d  %s",
		id, idAt, dock, dockAt, chanId, label)
        if ((idAt == "start") || (idAt == "phase"))
          printf("\n")
        else if ((idAt + 0) > id)
          printf("  ATTENTION: idAt > id!!!\n")
        else
          printf("\n")
      }
    }
    close(tmpfile)
    printf("\n\n")
  }
}

# +----------------------------------------+
# | function that evaluates new element-ID |
# |    assumes that the list contains a    |
# |    contiguous sequence of numbers!!    |
# +----------------------------------------+
function newId(id) {
  k = 1
  while ((idList[k] != id) && (k <= ix))
    k++
  if (k > ix)
    return(0)
  else
    return(k)
}

function terminate() {
  close(tmpfile)
  system("rm -f " tmpfile)
  exit
}'

if [ -s "$target".tmp ]; then
  mv "$target".tmp "$target"
else
  echo ""
  echo "   Missing sclib library components, or"
  echo "      elements missing otherwise in the converted sequence - "
  echo ""
  mv "$target" "$target".failed
fi

if [ -s "$target" ]; then
  echo " ... conversion complete."
  if [ $debug -eq 0 -a -s "$logfile" ]; then
    echo ""
    cat "$logfile"
    echo ""
  fi
else
  echo "   CONVERSION FAILED!"
fi

if [ $debug -eq 0 ]; then
  rm -f "$logfile"
  rm -f "$ff_tmptarget" "$ee_tmptarget" "$ee_tmptarget0"
  rm -f "$phstarget" "$source".tmp
  rm -f "$tbltarget"
fi
